<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>TURN client transport (2.4)</title>
<link href="/style/style.css" rel="stylesheet" type="text/css">
</head><body>
	<!--#include virtual="/header.html" -->
	<TABLE border=0 width="90%"><TR><TD>
	<p><A HREF="/">Home</A> --&gt; <A HREF="/docs.htm">Documentations</A> --&gt; <A HREF="/pjnath/docs/html/index.htm">PJNATH Reference</A></p>


<!-- Generated by Doxygen 1.7.6.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.htm"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.htm"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.htm"><span>Modules</span></a></li>
      <li><a href="annotated.htm"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.htm"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">TURN client transport</div>  </div>
<div class="ingroups"><a class="el" href="group__PJNATH__TURN.htm">TURN: Traversal Using Relays around NAT</a></div></div><!--header-->
<div class="contents">

<p>Client transport utilizing TURN relay.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpj__turn__sock__cb.htm">pj_turn_sock_cb</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpj__turn__sock__cfg.htm">pj_turn_sock_cfg</a></td></tr>
<tr><td colspan="2"><h2><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="group__PJNATH__TURN__SOCK.htm#ga1464ed784633ea88e143db46fe9e51c5">pj_turn_sock</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJNATH__TURN__SOCK.htm#ga1464ed784633ea88e143db46fe9e51c5">pj_turn_sock</a></td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJNATH__TURN__SOCK.htm#ga96e8ce38ef22d1645d8cb1e6e38d1022">pj_turn_sock_cfg_default</a> (<a class="el" href="structpj__turn__sock__cfg.htm">pj_turn_sock_cfg</a> *cfg)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">pj_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJNATH__TURN__SOCK.htm#ga3f738f3ed4b1c2a218fe00025bee90fa">pj_turn_sock_create</a> (<a class="el" href="structpj__stun__config.htm">pj_stun_config</a> *cfg, int af, <a class="el" href="group__PJNATH__TURN__SESSION.htm#ga0dfed6bb5edc5fe18950a46da5ff591e">pj_turn_tp_type</a> conn_type, const <a class="el" href="structpj__turn__sock__cb.htm">pj_turn_sock_cb</a> *cb, const <a class="el" href="structpj__turn__sock__cfg.htm">pj_turn_sock_cfg</a> *setting, void *user_data, <a class="el" href="group__PJNATH__TURN__SOCK.htm#ga1464ed784633ea88e143db46fe9e51c5">pj_turn_sock</a> **p_turn_sock)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJNATH__TURN__SOCK.htm#ga811bad900993b99b22df6673c067d2da">pj_turn_sock_destroy</a> (<a class="el" href="group__PJNATH__TURN__SOCK.htm#ga1464ed784633ea88e143db46fe9e51c5">pj_turn_sock</a> *turn_sock)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">pj_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJNATH__TURN__SOCK.htm#ga84821806b2725009b8be35f23eeb5193">pj_turn_sock_set_user_data</a> (<a class="el" href="group__PJNATH__TURN__SOCK.htm#ga1464ed784633ea88e143db46fe9e51c5">pj_turn_sock</a> *turn_sock, void *user_data)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJNATH__TURN__SOCK.htm#ga130dfbce55e91900a71c053b10006259">pj_turn_sock_get_user_data</a> (<a class="el" href="group__PJNATH__TURN__SOCK.htm#ga1464ed784633ea88e143db46fe9e51c5">pj_turn_sock</a> *turn_sock)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">pj_grp_lock_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJNATH__TURN__SOCK.htm#gad659b522f57e6c76a386bdf58676a8a8">pj_turn_sock_get_grp_lock</a> (<a class="el" href="group__PJNATH__TURN__SOCK.htm#ga1464ed784633ea88e143db46fe9e51c5">pj_turn_sock</a> *turn_sock)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">pj_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJNATH__TURN__SOCK.htm#ga9ea749b81cc851ec0b9fa44ffe14ab8e">pj_turn_sock_get_info</a> (<a class="el" href="group__PJNATH__TURN__SOCK.htm#ga1464ed784633ea88e143db46fe9e51c5">pj_turn_sock</a> *turn_sock, <a class="el" href="structpj__turn__session__info.htm">pj_turn_session_info</a> *info)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">pj_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJNATH__TURN__SOCK.htm#gab9aa4b59276544f9e2aeedccbc9f6362">pj_turn_sock_lock</a> (<a class="el" href="group__PJNATH__TURN__SOCK.htm#ga1464ed784633ea88e143db46fe9e51c5">pj_turn_sock</a> *turn_sock)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">pj_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJNATH__TURN__SOCK.htm#gaefcd7bf424b4079bdb0482c431654299">pj_turn_sock_unlock</a> (<a class="el" href="group__PJNATH__TURN__SOCK.htm#ga1464ed784633ea88e143db46fe9e51c5">pj_turn_sock</a> *turn_sock)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJNATH__TURN__SOCK.htm#ga0f96a71013fe8b01fccc90c753446c24">pj_turn_sock_set_log</a> (<a class="el" href="group__PJNATH__TURN__SOCK.htm#ga1464ed784633ea88e143db46fe9e51c5">pj_turn_sock</a> *turn_sock, unsigned flags)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">pj_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJNATH__TURN__SOCK.htm#gae2f736f9b9a01cd865cbf958c7a698ee">pj_turn_sock_set_software_name</a> (<a class="el" href="group__PJNATH__TURN__SOCK.htm#ga1464ed784633ea88e143db46fe9e51c5">pj_turn_sock</a> *turn_sock, const pj_str_t *sw)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">pj_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJNATH__TURN__SOCK.htm#gac9c675afdfb03b1e6dec315ce0acbbfc">pj_turn_sock_alloc</a> (<a class="el" href="group__PJNATH__TURN__SOCK.htm#ga1464ed784633ea88e143db46fe9e51c5">pj_turn_sock</a> *turn_sock, const pj_str_t *domain, int default_port, pj_dns_resolver *resolver, const <a class="el" href="structpj__stun__auth__cred.htm">pj_stun_auth_cred</a> *cred, const <a class="el" href="structpj__turn__alloc__param.htm">pj_turn_alloc_param</a> *param)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">pj_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJNATH__TURN__SOCK.htm#gae6b5794a40423d42d4657541d371584f">pj_turn_sock_set_perm</a> (<a class="el" href="group__PJNATH__TURN__SOCK.htm#ga1464ed784633ea88e143db46fe9e51c5">pj_turn_sock</a> *turn_sock, unsigned addr_cnt, const pj_sockaddr addr[], unsigned options)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">pj_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJNATH__TURN__SOCK.htm#gafe879e8db226a75a039eb5360d09d2cb">pj_turn_sock_sendto</a> (<a class="el" href="group__PJNATH__TURN__SOCK.htm#ga1464ed784633ea88e143db46fe9e51c5">pj_turn_sock</a> *turn_sock, const pj_uint8_t *pkt, unsigned pkt_len, const pj_sockaddr_t *peer_addr, unsigned addr_len)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">pj_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJNATH__TURN__SOCK.htm#ga7b315df95936322a222d91156fa61623">pj_turn_sock_bind_channel</a> (<a class="el" href="group__PJNATH__TURN__SOCK.htm#ga1464ed784633ea88e143db46fe9e51c5">pj_turn_sock</a> *turn_sock, const pj_sockaddr_t *peer, unsigned addr_len)</td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<p>This is a ready to use object for relaying application data via a TURN server, by managing all the operations in <a class="el" href="group__PJNATH__TURN.htm#turn_op_sec">Overview of TURN operations</a>.</p>
<h2><a class="anchor" id="turnsock_using_sec"></a>
Using TURN transport</h2>
<p>This object provides a thin wrapper to the <a class="el" href="group__PJNATH__TURN__SESSION.htm">TURN client session</a>, hence the API is very much the same (apart from the obvious difference in the names). Please see <a class="el" href="group__PJNATH__TURN__SESSION.htm">TURN client session</a> for the documentation on how to use the session.</p>
<h2><a class="anchor" id="turnsock_samples_sec"></a>
Samples</h2>
<p>The <a class="el" href="turn_client_sample.htm">pjturn-client, a sample TURN client</a> is a sample application to use the <a class="el" href="group__PJNATH__TURN__SOCK.htm">TURN client transport</a>.</p>
<p>Also see <b><a class="el" href="group__samples__page.htm">PJNATH Samples and screenshots</a></b> for other samples. </p>
<hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="ga1464ed784633ea88e143db46fe9e51c5"></a><!-- doxytag: member="turn_sock.h::pj_turn_sock" ref="ga1464ed784633ea88e143db46fe9e51c5" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="group__PJNATH__TURN__SOCK.htm#ga1464ed784633ea88e143db46fe9e51c5">pj_turn_sock</a> <a class="el" href="group__PJNATH__TURN__SOCK.htm#ga1464ed784633ea88e143db46fe9e51c5">pj_turn_sock</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Opaque declaration for TURN client. </p>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="gac9c675afdfb03b1e6dec315ce0acbbfc"></a><!-- doxytag: member="turn_sock.h::pj_turn_sock_alloc" ref="gac9c675afdfb03b1e6dec315ce0acbbfc" args="(pj_turn_sock *turn_sock, const pj_str_t *domain, int default_port, pj_dns_resolver *resolver, const pj_stun_auth_cred *cred, const pj_turn_alloc_param *param)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pj_status_t <a class="el" href="group__PJNATH__TURN__SOCK.htm#gac9c675afdfb03b1e6dec315ce0acbbfc">pj_turn_sock_alloc</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__PJNATH__TURN__SOCK.htm#ga1464ed784633ea88e143db46fe9e51c5">pj_turn_sock</a> *&#160;</td>
          <td class="paramname"><em>turn_sock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const pj_str_t *&#160;</td>
          <td class="paramname"><em>domain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>default_port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pj_dns_resolver *&#160;</td>
          <td class="paramname"><em>resolver</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpj__stun__auth__cred.htm">pj_stun_auth_cred</a> *&#160;</td>
          <td class="paramname"><em>cred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpj__turn__alloc__param.htm">pj_turn_alloc_param</a> *&#160;</td>
          <td class="paramname"><em>param</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Allocate a relay address/resource in the TURN server. This function will resolve the TURN server using DNS SRV (if desired) and send TURN <em>Allocate</em> request using the specified credential to allocate a relay address in the server. This function completes asynchronously, and application will be notified when the allocation process has been successful in the <em>on_state()</em> callback when the state is set to PJ_TURN_STATE_READY. If the allocation fails, the state will be set to PJ_TURN_STATE_DEALLOCATING or greater.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">turn_sock</td><td>The TURN transport instance. </td></tr>
    <tr><td class="paramname">domain</td><td>The domain, hostname, or IP address of the TURN server. When this parameter contains domain name, the <em>resolver</em> parameter must be set to activate DNS SRV resolution. </td></tr>
    <tr><td class="paramname">default_port</td><td>The default TURN port number to use when DNS SRV resolution is not used. If DNS SRV resolution is used, the server port number will be set from the DNS SRV records. </td></tr>
    <tr><td class="paramname">resolver</td><td>If this parameter is not NULL, then the <em>domain</em> parameter will be first resolved with DNS SRV and then fallback to using DNS A/AAAA resolution when DNS SRV resolution fails. If this parameter is NULL, the <em>domain</em> parameter will be resolved as hostname. </td></tr>
    <tr><td class="paramname">cred</td><td>The STUN credential to be used for the TURN server. </td></tr>
    <tr><td class="paramname">param</td><td>Optional TURN allocation parameter.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>PJ_SUCCESS if the operation has been successfully queued, or the appropriate error code on failure. When this function returns PJ_SUCCESS, the final result of the allocation process will be notified to application in <em>on_state()</em> callback. </dd></dl>

</div>
</div>
<a class="anchor" id="ga7b315df95936322a222d91156fa61623"></a><!-- doxytag: member="turn_sock.h::pj_turn_sock_bind_channel" ref="ga7b315df95936322a222d91156fa61623" args="(pj_turn_sock *turn_sock, const pj_sockaddr_t *peer, unsigned addr_len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pj_status_t <a class="el" href="group__PJNATH__TURN__SOCK.htm#ga7b315df95936322a222d91156fa61623">pj_turn_sock_bind_channel</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__PJNATH__TURN__SOCK.htm#ga1464ed784633ea88e143db46fe9e51c5">pj_turn_sock</a> *&#160;</td>
          <td class="paramname"><em>turn_sock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const pj_sockaddr_t *&#160;</td>
          <td class="paramname"><em>peer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>addr_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Optionally establish channel binding for the specified a peer address. This function will assign a unique channel number for the peer address and request channel binding to the TURN server for this address. When a channel has been bound to a peer, the TURN transport and TURN server will exchange data using ChannelData encapsulation format, which has lower bandwidth overhead than Send Indication (the default format used when peer address is not bound to a channel).</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">turn_sock</td><td>The TURN transport instance. </td></tr>
    <tr><td class="paramname">peer</td><td>The remote peer address. </td></tr>
    <tr><td class="paramname">addr_len</td><td>Length of the address.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>PJ_SUCCESS if the operation has been successful, or the appropriate error code on failure. </dd></dl>

</div>
</div>
<a class="anchor" id="ga96e8ce38ef22d1645d8cb1e6e38d1022"></a><!-- doxytag: member="turn_sock.h::pj_turn_sock_cfg_default" ref="ga96e8ce38ef22d1645d8cb1e6e38d1022" args="(pj_turn_sock_cfg *cfg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__PJNATH__TURN__SOCK.htm#ga96e8ce38ef22d1645d8cb1e6e38d1022">pj_turn_sock_cfg_default</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpj__turn__sock__cfg.htm">pj_turn_sock_cfg</a> *&#160;</td>
          <td class="paramname"><em>cfg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Initialize <a class="el" href="structpj__turn__sock__cfg.htm">pj_turn_sock_cfg</a> structure with default values. </p>

</div>
</div>
<a class="anchor" id="ga3f738f3ed4b1c2a218fe00025bee90fa"></a><!-- doxytag: member="turn_sock.h::pj_turn_sock_create" ref="ga3f738f3ed4b1c2a218fe00025bee90fa" args="(pj_stun_config *cfg, int af, pj_turn_tp_type conn_type, const pj_turn_sock_cb *cb, const pj_turn_sock_cfg *setting, void *user_data, pj_turn_sock **p_turn_sock)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pj_status_t <a class="el" href="group__PJNATH__TURN__SOCK.htm#ga3f738f3ed4b1c2a218fe00025bee90fa">pj_turn_sock_create</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpj__stun__config.htm">pj_stun_config</a> *&#160;</td>
          <td class="paramname"><em>cfg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>af</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PJNATH__TURN__SESSION.htm#ga0dfed6bb5edc5fe18950a46da5ff591e">pj_turn_tp_type</a>&#160;</td>
          <td class="paramname"><em>conn_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpj__turn__sock__cb.htm">pj_turn_sock_cb</a> *&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpj__turn__sock__cfg.htm">pj_turn_sock_cfg</a> *&#160;</td>
          <td class="paramname"><em>setting</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PJNATH__TURN__SOCK.htm#ga1464ed784633ea88e143db46fe9e51c5">pj_turn_sock</a> **&#160;</td>
          <td class="paramname"><em>p_turn_sock</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a TURN transport instance with the specified address family and connection type. Once TURN transport instance is created, application must call <a class="el" href="group__PJNATH__TURN__SOCK.htm#gac9c675afdfb03b1e6dec315ce0acbbfc">pj_turn_sock_alloc()</a> to allocate a relay address in the TURN server.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">cfg</td><td>The STUN configuration which contains among other things the ioqueue and timer heap instance for the operation of this transport. </td></tr>
    <tr><td class="paramname">af</td><td>Address family of the client connection. Currently pj_AF_INET() and pj_AF_INET6() are supported. </td></tr>
    <tr><td class="paramname">conn_type</td><td>Connection type to the TURN server. Both TCP and UDP are supported. </td></tr>
    <tr><td class="paramname">cb</td><td>Callback to receive events from the TURN transport. </td></tr>
    <tr><td class="paramname">setting</td><td>Optional settings to be specified to the transport. If this parameter is NULL, default values will be used. </td></tr>
    <tr><td class="paramname">user_data</td><td>Arbitrary application data to be associated with this transport. </td></tr>
    <tr><td class="paramname">p_turn_sock</td><td>Pointer to receive the created instance of the TURN transport.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>PJ_SUCCESS if the operation has been successful, or the appropriate error code on failure. </dd></dl>

</div>
</div>
<a class="anchor" id="ga811bad900993b99b22df6673c067d2da"></a><!-- doxytag: member="turn_sock.h::pj_turn_sock_destroy" ref="ga811bad900993b99b22df6673c067d2da" args="(pj_turn_sock *turn_sock)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__PJNATH__TURN__SOCK.htm#ga811bad900993b99b22df6673c067d2da">pj_turn_sock_destroy</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__PJNATH__TURN__SOCK.htm#ga1464ed784633ea88e143db46fe9e51c5">pj_turn_sock</a> *&#160;</td>
          <td class="paramname"><em>turn_sock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Destroy the TURN transport instance. This will gracefully close the connection between the client and the TURN server. Although this function will return immediately, the TURN socket deletion may continue in the background and the application may still get state changes notifications from this transport.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">turn_sock</td><td>The TURN transport instance. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gad659b522f57e6c76a386bdf58676a8a8"></a><!-- doxytag: member="turn_sock.h::pj_turn_sock_get_grp_lock" ref="gad659b522f57e6c76a386bdf58676a8a8" args="(pj_turn_sock *turn_sock)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pj_grp_lock_t* <a class="el" href="group__PJNATH__TURN__SOCK.htm#gad659b522f57e6c76a386bdf58676a8a8">pj_turn_sock_get_grp_lock</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__PJNATH__TURN__SOCK.htm#ga1464ed784633ea88e143db46fe9e51c5">pj_turn_sock</a> *&#160;</td>
          <td class="paramname"><em>turn_sock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get the group lock for this TURN transport.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">turn_sock</td><td>The TURN transport instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The group lock. </dd></dl>

</div>
</div>
<a class="anchor" id="ga9ea749b81cc851ec0b9fa44ffe14ab8e"></a><!-- doxytag: member="turn_sock.h::pj_turn_sock_get_info" ref="ga9ea749b81cc851ec0b9fa44ffe14ab8e" args="(pj_turn_sock *turn_sock, pj_turn_session_info *info)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pj_status_t <a class="el" href="group__PJNATH__TURN__SOCK.htm#ga9ea749b81cc851ec0b9fa44ffe14ab8e">pj_turn_sock_get_info</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__PJNATH__TURN__SOCK.htm#ga1464ed784633ea88e143db46fe9e51c5">pj_turn_sock</a> *&#160;</td>
          <td class="paramname"><em>turn_sock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpj__turn__session__info.htm">pj_turn_session_info</a> *&#160;</td>
          <td class="paramname"><em>info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get the TURN transport info. The transport info contains, among other things, the allocated relay address.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">turn_sock</td><td>The TURN transport instance. </td></tr>
    <tr><td class="paramname">info</td><td>Pointer to be filled with TURN transport info.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>PJ_SUCCESS if the operation has been successful, or the appropriate error code on failure. </dd></dl>

</div>
</div>
<a class="anchor" id="ga130dfbce55e91900a71c053b10006259"></a><!-- doxytag: member="turn_sock.h::pj_turn_sock_get_user_data" ref="ga130dfbce55e91900a71c053b10006259" args="(pj_turn_sock *turn_sock)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* <a class="el" href="group__PJNATH__TURN__SOCK.htm#ga130dfbce55e91900a71c053b10006259">pj_turn_sock_get_user_data</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__PJNATH__TURN__SOCK.htm#ga1464ed784633ea88e143db46fe9e51c5">pj_turn_sock</a> *&#160;</td>
          <td class="paramname"><em>turn_sock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Retrieve the previously assigned user data associated with this TURN transport.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">turn_sock</td><td>The TURN transport instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The user/application data. </dd></dl>

</div>
</div>
<a class="anchor" id="gab9aa4b59276544f9e2aeedccbc9f6362"></a><!-- doxytag: member="turn_sock.h::pj_turn_sock_lock" ref="gab9aa4b59276544f9e2aeedccbc9f6362" args="(pj_turn_sock *turn_sock)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pj_status_t <a class="el" href="group__PJNATH__TURN__SOCK.htm#gab9aa4b59276544f9e2aeedccbc9f6362">pj_turn_sock_lock</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__PJNATH__TURN__SOCK.htm#ga1464ed784633ea88e143db46fe9e51c5">pj_turn_sock</a> *&#160;</td>
          <td class="paramname"><em>turn_sock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Acquire the internal mutex of the TURN transport. Application may need to call this function to synchronize access to other objects alongside the TURN transport, to avoid deadlock.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">turn_sock</td><td>The TURN transport instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>PJ_SUCCESS if the operation has been successful, or the appropriate error code on failure. </dd></dl>

</div>
</div>
<a class="anchor" id="gafe879e8db226a75a039eb5360d09d2cb"></a><!-- doxytag: member="turn_sock.h::pj_turn_sock_sendto" ref="gafe879e8db226a75a039eb5360d09d2cb" args="(pj_turn_sock *turn_sock, const pj_uint8_t *pkt, unsigned pkt_len, const pj_sockaddr_t *peer_addr, unsigned addr_len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pj_status_t <a class="el" href="group__PJNATH__TURN__SOCK.htm#gafe879e8db226a75a039eb5360d09d2cb">pj_turn_sock_sendto</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__PJNATH__TURN__SOCK.htm#ga1464ed784633ea88e143db46fe9e51c5">pj_turn_sock</a> *&#160;</td>
          <td class="paramname"><em>turn_sock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const pj_uint8_t *&#160;</td>
          <td class="paramname"><em>pkt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>pkt_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const pj_sockaddr_t *&#160;</td>
          <td class="paramname"><em>peer_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>addr_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Send a data to the specified peer address via the TURN relay. This function will encapsulate the data as STUN Send Indication or TURN ChannelData packet and send the message to the TURN server. The TURN server then will send the data to the peer.</p>
<p>The allocation (<a class="el" href="group__PJNATH__TURN__SOCK.htm#gac9c675afdfb03b1e6dec315ce0acbbfc">pj_turn_sock_alloc()</a>) must have been successfully created before application can relay any data.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">turn_sock</td><td>The TURN transport instance. </td></tr>
    <tr><td class="paramname">pkt</td><td>The data/packet to be sent to peer. </td></tr>
    <tr><td class="paramname">pkt_len</td><td>Length of the data. </td></tr>
    <tr><td class="paramname">peer_addr</td><td>The remote peer address (the ultimate destination of the data, and not the TURN server address). </td></tr>
    <tr><td class="paramname">addr_len</td><td>Length of the address.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>PJ_SUCCESS if the operation has been successful, or the appropriate error code on failure. </dd></dl>

</div>
</div>
<a class="anchor" id="ga0f96a71013fe8b01fccc90c753446c24"></a><!-- doxytag: member="turn_sock.h::pj_turn_sock_set_log" ref="ga0f96a71013fe8b01fccc90c753446c24" args="(pj_turn_sock *turn_sock, unsigned flags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__PJNATH__TURN__SOCK.htm#ga0f96a71013fe8b01fccc90c753446c24">pj_turn_sock_set_log</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__PJNATH__TURN__SOCK.htm#ga1464ed784633ea88e143db46fe9e51c5">pj_turn_sock</a> *&#160;</td>
          <td class="paramname"><em>turn_sock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set STUN message logging for this TURN session. See <a class="el" href="group__PJNATH__STUN__SESSION.htm#ga797c00bf8022aebe191e9a4c2d46fd2f">pj_stun_session_set_log()</a>.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">turn_sock</td><td>The TURN transport instance. </td></tr>
    <tr><td class="paramname">flags</td><td>Bitmask combination of <a class="el" href="group__PJNATH__STUN__SESSION.htm#ga65952e3ea20202965284021d5086e48d">pj_stun_sess_msg_log_flag</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gae6b5794a40423d42d4657541d371584f"></a><!-- doxytag: member="turn_sock.h::pj_turn_sock_set_perm" ref="gae6b5794a40423d42d4657541d371584f" args="(pj_turn_sock *turn_sock, unsigned addr_cnt, const pj_sockaddr addr[], unsigned options)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pj_status_t <a class="el" href="group__PJNATH__TURN__SOCK.htm#gae6b5794a40423d42d4657541d371584f">pj_turn_sock_set_perm</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__PJNATH__TURN__SOCK.htm#ga1464ed784633ea88e143db46fe9e51c5">pj_turn_sock</a> *&#160;</td>
          <td class="paramname"><em>turn_sock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>addr_cnt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const pj_sockaddr&#160;</td>
          <td class="paramname"><em>addr</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create or renew permission in the TURN server for the specified peer IP addresses. Application must install permission for a particular (peer) IP address before it sends any data to that IP address, or otherwise the TURN server will drop the data.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">turn_sock</td><td>The TURN transport instance. </td></tr>
    <tr><td class="paramname">addr_cnt</td><td>Number of IP addresses. </td></tr>
    <tr><td class="paramname">addr</td><td>Array of peer IP addresses. Only the address family and IP address portion of the socket address matter. </td></tr>
    <tr><td class="paramname">options</td><td>Specify 1 to let the TURN client session automatically renew the permission later when they are about to expire.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>PJ_SUCCESS if the operation has been successfully issued, or the appropriate error code. Note that the operation itself will complete asynchronously. </dd></dl>

</div>
</div>
<a class="anchor" id="gae2f736f9b9a01cd865cbf958c7a698ee"></a><!-- doxytag: member="turn_sock.h::pj_turn_sock_set_software_name" ref="gae2f736f9b9a01cd865cbf958c7a698ee" args="(pj_turn_sock *turn_sock, const pj_str_t *sw)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pj_status_t <a class="el" href="group__PJNATH__TURN__SOCK.htm#gae2f736f9b9a01cd865cbf958c7a698ee">pj_turn_sock_set_software_name</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__PJNATH__TURN__SOCK.htm#ga1464ed784633ea88e143db46fe9e51c5">pj_turn_sock</a> *&#160;</td>
          <td class="paramname"><em>turn_sock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const pj_str_t *&#160;</td>
          <td class="paramname"><em>sw</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Configure the SOFTWARE name to be sent in all STUN requests by the TURN session.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">turn_sock</td><td>The TURN transport instance. </td></tr>
    <tr><td class="paramname">sw</td><td>Software name string. If this argument is NULL or empty, the session will not include SOFTWARE attribute in STUN requests and responses.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>PJ_SUCCESS on success, or the appropriate error code. </dd></dl>

</div>
</div>
<a class="anchor" id="ga84821806b2725009b8be35f23eeb5193"></a><!-- doxytag: member="turn_sock.h::pj_turn_sock_set_user_data" ref="ga84821806b2725009b8be35f23eeb5193" args="(pj_turn_sock *turn_sock, void *user_data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pj_status_t <a class="el" href="group__PJNATH__TURN__SOCK.htm#ga84821806b2725009b8be35f23eeb5193">pj_turn_sock_set_user_data</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__PJNATH__TURN__SOCK.htm#ga1464ed784633ea88e143db46fe9e51c5">pj_turn_sock</a> *&#160;</td>
          <td class="paramname"><em>turn_sock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Associate a user data with this TURN transport. The user data may then be retrieved later with <a class="el" href="group__PJNATH__TURN__SOCK.htm#ga130dfbce55e91900a71c053b10006259">pj_turn_sock_get_user_data()</a>.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">turn_sock</td><td>The TURN transport instance. </td></tr>
    <tr><td class="paramname">user_data</td><td>Arbitrary data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>PJ_SUCCESS if the operation has been successful, or the appropriate error code on failure. </dd></dl>

</div>
</div>
<a class="anchor" id="gaefcd7bf424b4079bdb0482c431654299"></a><!-- doxytag: member="turn_sock.h::pj_turn_sock_unlock" ref="gaefcd7bf424b4079bdb0482c431654299" args="(pj_turn_sock *turn_sock)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pj_status_t <a class="el" href="group__PJNATH__TURN__SOCK.htm#gaefcd7bf424b4079bdb0482c431654299">pj_turn_sock_unlock</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__PJNATH__TURN__SOCK.htm#ga1464ed784633ea88e143db46fe9e51c5">pj_turn_sock</a> *&#160;</td>
          <td class="paramname"><em>turn_sock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Release the internal mutex previously held with <a class="el" href="group__PJNATH__TURN__SOCK.htm#gab9aa4b59276544f9e2aeedccbc9f6362">pj_turn_sock_lock()</a>.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">turn_sock</td><td>The TURN transport instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>PJ_SUCCESS if the operation has been successful, or the appropriate error code on failure. </dd></dl>

</div>
</div>
</div><!-- contents -->
	</TD></TD></TABLE>
<p>&nbsp;</p>
<hr><center>
PJNATH - Open Source NAT traversal helper library supporting STUN, TURN, and ICE<br>
Copyright (C) 2006-2009 Teluu Inc.
</center>


<!--#include virtual="/footer.html" -->

</BODY>
</HTML>
