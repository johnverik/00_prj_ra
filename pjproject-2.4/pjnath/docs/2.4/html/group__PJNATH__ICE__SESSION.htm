<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>ICE Session (2.4)</title>
<link href="/style/style.css" rel="stylesheet" type="text/css">
</head><body>
	<!--#include virtual="/header.html" -->
	<TABLE border=0 width="90%"><TR><TD>
	<p><A HREF="/">Home</A> --&gt; <A HREF="/docs.htm">Documentations</A> --&gt; <A HREF="/pjnath/docs/html/index.htm">PJNATH Reference</A></p>


<!-- Generated by Doxygen 1.7.6.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.htm"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.htm"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.htm"><span>Modules</span></a></li>
      <li><a href="annotated.htm"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.htm"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">ICE Session</div>  </div>
<div class="ingroups"><a class="el" href="group__PJNATH__ICE.htm">ICE: Interactive Connectivity Establishment</a></div></div><!--header-->
<div class="contents">

<p>Transport Independent ICE Session.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpj__ice__sess__comp.htm">pj_ice_sess_comp</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpj__ice__msg__data.htm">pj_ice_msg_data</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpj__ice__sess__cand.htm">pj_ice_sess_cand</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpj__ice__sess__check.htm">pj_ice_sess_check</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpj__ice__sess__checklist.htm">pj_ice_sess_checklist</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpj__ice__sess__cb.htm">pj_ice_sess_cb</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpj__ice__rx__check.htm">pj_ice_rx_check</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpj__ice__sess__options.htm">pj_ice_sess_options</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpj__ice__sess.htm">pj_ice_sess</a></td></tr>
<tr><td colspan="2"><h2><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJNATH__ICE__SESSION.htm#gaf1efc18bd5354bbb7e31f2d538590195">pj_ice_cand_type</a> { <br/>
&#160;&#160;<a class="el" href="group__PJNATH__ICE__SESSION.htm#ggaf1efc18bd5354bbb7e31f2d538590195ab0d5685346080516dfd851b7d795da4a">PJ_ICE_CAND_TYPE_HOST</a>, 
<br/>
&#160;&#160;<a class="el" href="group__PJNATH__ICE__SESSION.htm#ggaf1efc18bd5354bbb7e31f2d538590195ab1b228669c93311321c56d7ffcd3720a">PJ_ICE_CAND_TYPE_SRFLX</a>, 
<br/>
&#160;&#160;<a class="el" href="group__PJNATH__ICE__SESSION.htm#ggaf1efc18bd5354bbb7e31f2d538590195a781d3f8b892a5e8ef2e949e6b3f6ab6c">PJ_ICE_CAND_TYPE_PRFLX</a>, 
<br/>
&#160;&#160;<a class="el" href="group__PJNATH__ICE__SESSION.htm#ggaf1efc18bd5354bbb7e31f2d538590195a175a194dc076f6c35fb7cd0a094e7207">PJ_ICE_CAND_TYPE_RELAYED</a>, 
<br/>
&#160;&#160;<a class="el" href="group__PJNATH__ICE__SESSION.htm#ggaf1efc18bd5354bbb7e31f2d538590195a0c5911b7351c658165203a8ac947cdea">PJ_ICE_CAND_TYPE_MAX</a>
<br/>
 }</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJNATH__ICE__SESSION.htm#ga95e83706882f6df82253a96978cb9f95">pj_ice_sess_check_state</a> { <br/>
&#160;&#160;<a class="el" href="group__PJNATH__ICE__SESSION.htm#gga95e83706882f6df82253a96978cb9f95ad34f96adb70060d37d049821b0556c0a">PJ_ICE_SESS_CHECK_STATE_FROZEN</a>, 
<br/>
&#160;&#160;<a class="el" href="group__PJNATH__ICE__SESSION.htm#gga95e83706882f6df82253a96978cb9f95a35ebf5af4cab1aaac022cd7e8b950779">PJ_ICE_SESS_CHECK_STATE_WAITING</a>, 
<br/>
&#160;&#160;<a class="el" href="group__PJNATH__ICE__SESSION.htm#gga95e83706882f6df82253a96978cb9f95a1035a80420eb534f29de5325fca6e65b">PJ_ICE_SESS_CHECK_STATE_IN_PROGRESS</a>, 
<br/>
&#160;&#160;<a class="el" href="group__PJNATH__ICE__SESSION.htm#gga95e83706882f6df82253a96978cb9f95af2e8117b3e9bb9524ef8cacd6c4ddcbf">PJ_ICE_SESS_CHECK_STATE_SUCCEEDED</a>, 
<br/>
&#160;&#160;<a class="el" href="group__PJNATH__ICE__SESSION.htm#gga95e83706882f6df82253a96978cb9f95a59d46061551f63bf01102724fc78a692">PJ_ICE_SESS_CHECK_STATE_FAILED</a>
<br/>
 }</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJNATH__ICE__SESSION.htm#ga19dac31520f06372af6b6f51dcf87067">pj_ice_sess_checklist_state</a> { <br/>
&#160;&#160;<a class="el" href="group__PJNATH__ICE__SESSION.htm#gga19dac31520f06372af6b6f51dcf87067a97d7a7f5a2a85c93fd4036dac777e58a">PJ_ICE_SESS_CHECKLIST_ST_IDLE</a>, 
<br/>
&#160;&#160;<a class="el" href="group__PJNATH__ICE__SESSION.htm#gga19dac31520f06372af6b6f51dcf87067a98f4119b8465605e66baad82cb4204c7">PJ_ICE_SESS_CHECKLIST_ST_RUNNING</a>, 
<br/>
&#160;&#160;<a class="el" href="group__PJNATH__ICE__SESSION.htm#gga19dac31520f06372af6b6f51dcf87067a9720334d73272d58f466908b78187530">PJ_ICE_SESS_CHECKLIST_ST_COMPLETED</a>
<br/>
 }</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJNATH__ICE__SESSION.htm#ga1d005022224e45654bcdef0eeafae217">pj_ice_sess_role</a> { <br/>
&#160;&#160;<a class="el" href="group__PJNATH__ICE__SESSION.htm#gga1d005022224e45654bcdef0eeafae217a1513fa3b134a0784bfab297f995c0f3e">PJ_ICE_SESS_ROLE_UNKNOWN</a>, 
<br/>
&#160;&#160;<a class="el" href="group__PJNATH__ICE__SESSION.htm#gga1d005022224e45654bcdef0eeafae217adf65b85e5be9f6e1e22aa0e06c64476c">PJ_ICE_SESS_ROLE_CONTROLLED</a>, 
<br/>
&#160;&#160;<a class="el" href="group__PJNATH__ICE__SESSION.htm#gga1d005022224e45654bcdef0eeafae217a5b0145b939df96bee579f4d368203b8c">PJ_ICE_SESS_ROLE_CONTROLLING</a>
<br/>
 }</td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJNATH__ICE__SESSION.htm#ga18fd89ecc361d0d0282b856ef62814c1">pj_ice_get_cand_type_name</a> (<a class="el" href="group__PJNATH__ICE__SESSION.htm#gaf1efc18bd5354bbb7e31f2d538590195">pj_ice_cand_type</a> type)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJNATH__ICE__SESSION.htm#ga06cb4ce81895ab34f06943ae30860f1a">pj_ice_sess_role_name</a> (<a class="el" href="group__PJNATH__ICE__SESSION.htm#ga1d005022224e45654bcdef0eeafae217">pj_ice_sess_role</a> role)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJNATH__ICE__SESSION.htm#gaaf86099f9ea896cafadceaa223b929a6">pj_ice_calc_foundation</a> (pj_pool_t *pool, pj_str_t *foundation, <a class="el" href="group__PJNATH__ICE__SESSION.htm#gaf1efc18bd5354bbb7e31f2d538590195">pj_ice_cand_type</a> type, const pj_sockaddr *base_addr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJNATH__ICE__SESSION.htm#ga3a7278988931dd6ab04c10d6d936e972">pj_ice_sess_options_default</a> (<a class="el" href="structpj__ice__sess__options.htm">pj_ice_sess_options</a> *opt)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">pj_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJNATH__ICE__SESSION.htm#ga68627f100f7a316645ca534e18a5477d">pj_ice_sess_create</a> (<a class="el" href="structpj__stun__config.htm">pj_stun_config</a> *stun_cfg, const char *name, <a class="el" href="group__PJNATH__ICE__SESSION.htm#ga1d005022224e45654bcdef0eeafae217">pj_ice_sess_role</a> role, unsigned comp_cnt, const <a class="el" href="structpj__ice__sess__cb.htm">pj_ice_sess_cb</a> *cb, const pj_str_t *local_ufrag, const pj_str_t *local_passwd, pj_grp_lock_t *grp_lock, <a class="el" href="structpj__ice__sess.htm">pj_ice_sess</a> **p_ice)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">pj_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJNATH__ICE__SESSION.htm#gaf49d920b20f3d0f8833531cb98a7fb84">pj_ice_sess_get_options</a> (<a class="el" href="structpj__ice__sess.htm">pj_ice_sess</a> *ice, <a class="el" href="structpj__ice__sess__options.htm">pj_ice_sess_options</a> *opt)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">pj_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJNATH__ICE__SESSION.htm#ga0c61188a773832277c8559fe0713946f">pj_ice_sess_set_options</a> (<a class="el" href="structpj__ice__sess.htm">pj_ice_sess</a> *ice, const <a class="el" href="structpj__ice__sess__options.htm">pj_ice_sess_options</a> *opt)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">pj_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJNATH__ICE__SESSION.htm#gac96792c078b5d9eed6f20d0747a291f0">pj_ice_sess_destroy</a> (<a class="el" href="structpj__ice__sess.htm">pj_ice_sess</a> *ice)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">pj_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJNATH__ICE__SESSION.htm#ga8e8c53cb47d14494080a93715b185480">pj_ice_sess_change_role</a> (<a class="el" href="structpj__ice__sess.htm">pj_ice_sess</a> *ice, <a class="el" href="group__PJNATH__ICE__SESSION.htm#ga1d005022224e45654bcdef0eeafae217">pj_ice_sess_role</a> new_role)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">pj_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJNATH__ICE__SESSION.htm#ga819f43e9f3690174c3f0f011b2ad8e9e">pj_ice_sess_set_prefs</a> (<a class="el" href="structpj__ice__sess.htm">pj_ice_sess</a> *ice, const pj_uint8_t prefs[4])</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">pj_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJNATH__ICE__SESSION.htm#gaca953988f0f3a0580c189218996b7ece">pj_ice_sess_add_cand</a> (<a class="el" href="structpj__ice__sess.htm">pj_ice_sess</a> *ice, unsigned comp_id, unsigned transport_id, <a class="el" href="group__PJNATH__ICE__SESSION.htm#gaf1efc18bd5354bbb7e31f2d538590195">pj_ice_cand_type</a> type, pj_uint16_t local_pref, const pj_str_t *foundation, const pj_sockaddr_t *addr, const pj_sockaddr_t *base_addr, const pj_sockaddr_t *rel_addr, int addr_len, unsigned *p_cand_id)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">pj_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJNATH__ICE__SESSION.htm#gacd6f2284b80728cf3077a6dc007b5911">pj_ice_sess_find_default_cand</a> (<a class="el" href="structpj__ice__sess.htm">pj_ice_sess</a> *ice, unsigned comp_id, int *p_cand_id)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">pj_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJNATH__ICE__SESSION.htm#gaf8efccb541d729c38fb975d1f56fb3f8">pj_ice_sess_create_check_list</a> (<a class="el" href="structpj__ice__sess.htm">pj_ice_sess</a> *ice, const pj_str_t *rem_ufrag, const pj_str_t *rem_passwd, unsigned rem_cand_cnt, const <a class="el" href="structpj__ice__sess__cand.htm">pj_ice_sess_cand</a> rem_cand[])</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">pj_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJNATH__ICE__SESSION.htm#ga9f65ac601ea1b86ef2b17fa4c7ef902a">pj_ice_sess_start_check</a> (<a class="el" href="structpj__ice__sess.htm">pj_ice_sess</a> *ice)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">pj_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJNATH__ICE__SESSION.htm#gafadfb77d6a0cff9434f8d6a9943a803e">pj_ice_sess_send_data</a> (<a class="el" href="structpj__ice__sess.htm">pj_ice_sess</a> *ice, unsigned comp_id, const void *data, pj_size_t data_len)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">pj_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJNATH__ICE__SESSION.htm#ga27c9da6a420cd0d1c8a3e2fd7136165f">pj_ice_sess_on_rx_pkt</a> (<a class="el" href="structpj__ice__sess.htm">pj_ice_sess</a> *ice, unsigned comp_id, unsigned transport_id, void *pkt, pj_size_t pkt_size, const pj_sockaddr_t *src_addr, int src_addr_len)</td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<p>This module describes <a class="el" href="structpj__ice__sess.htm">pj_ice_sess</a>, a transport independent ICE session, part of PJNATH - the Open Source NAT helper library.</p>
<h2><a class="anchor" id="pj_ice_sess_sec"></a>
ICE Session</h2>
<p>An ICE session, represented by <a class="el" href="structpj__ice__sess.htm">pj_ice_sess</a> structure, is the lowest abstraction of ICE in PJNATH, and it is used to perform and manage connectivity checks of transport address candidates <b>within a single media stream</b> (note: this differs from what is described in ICE draft, where an ICE session manages the whole media sessions rather than just a single stream).</p>
<p>The ICE session described here is independent from any transports, meaning that the actual network I/O for this session would have to be performed by the application, or higher layer abstraction. Using this framework, application would give any incoming packets to the ICE session, and it would provide the ICE session with a callback to send outgoing message.</p>
<p>For higher abstraction of ICE where transport is included, please see <a class="el" href="group__PJNATH__ICE__STREAM__TRANSPORT.htm">ICE stream transport</a>.</p>
<h3><a class="anchor" id="pj_ice_sess_using_sec"></a>
Using The ICE Session</h3>
<p>The steps below describe how to use ICE session. Alternatively application can use the higher level ICE API, <a class="el" href="group__PJNATH__ICE__STREAM__TRANSPORT.htm">ICE stream transport</a>, which has provided the integration of ICE with socket transport.</p>
<p>The steps to use ICE session is similar for both offerer and answerer:</p>
<ul>
<li>create ICE session with <a class="el" href="group__PJNATH__ICE__SESSION.htm#ga68627f100f7a316645ca534e18a5477d">pj_ice_sess_create()</a>. Among other things, application needs to specify:<ul>
<li>STUN configuration (<a class="el" href="structpj__stun__config.htm">pj_stun_config</a>), containing STUN settings such as timeout values and the instances of timer heap and ioqueue.</li>
<li>Session name, useful for identifying this session in the log.</li>
<li>Initial ICE role (<a class="el" href="group__PJNATH__ICE__SESSION.htm#ga1d005022224e45654bcdef0eeafae217">pj_ice_sess_role</a>). The role can be changed at later time with <a class="el" href="group__PJNATH__ICE__SESSION.htm#ga8e8c53cb47d14494080a93715b185480">pj_ice_sess_change_role()</a>, and ICE session can also change its role automatically when it detects role conflict.</li>
<li>Number of components in the media session.</li>
<li>Callback to receive ICE events (<a class="el" href="structpj__ice__sess__cb.htm">pj_ice_sess_cb</a>)</li>
<li>Optional local ICE username and password. If these arguments are NULL, they will be generated randomly.</li>
</ul>
</li>
<li>Add local candidates for each component, with <a class="el" href="group__PJNATH__ICE__SESSION.htm#gaca953988f0f3a0580c189218996b7ece">pj_ice_sess_add_cand()</a>. A candidate is represented with <a class="el" href="structpj__ice__sess__cand.htm">pj_ice_sess_cand</a> structure. Each component must be provided with at least one candidate, and all components must have the same number of candidates. Failing to comply with this will cause failure during pairing process.</li>
<li>Create offer to describe local ICE candidates. ICE session does not provide a function to create such offer, but application should be able to create one since it knows about all components and candidates. If application uses <a class="el" href="group__PJNATH__ICE__STREAM__TRANSPORT.htm">ICE stream transport</a>, it can enumerate local candidates by calling <a class="el" href="group__PJNATH__ICE__STREAM__TRANSPORT.htm#ga597a3c3493038d8b37ff0a63e8ad93e5">pj_ice_strans_enum_cands()</a>. Application may use <a class="el" href="group__PJNATH__ICE__SESSION.htm#gacd6f2284b80728cf3077a6dc007b5911">pj_ice_sess_find_default_cand()</a> to let ICE session chooses the default transport address to be used in SDP c= and m= lines.</li>
<li>Send the offer to remote endpoint using signaling such as SIP.</li>
<li>Once application has received the answer, it should parse this answer, build array of remote candidates, and create check lists by calling <a class="el" href="group__PJNATH__ICE__SESSION.htm#gaf8efccb541d729c38fb975d1f56fb3f8">pj_ice_sess_create_check_list()</a>. This process is known as pairing the candidates, and will result in the creation of check lists.</li>
<li>Once checklist has been created, application then can call <a class="el" href="group__PJNATH__ICE__SESSION.htm#ga9f65ac601ea1b86ef2b17fa4c7ef902a">pj_ice_sess_start_check()</a> to instruct ICE session to start performing connectivity checks. The ICE session performs the connectivity checks by processing each check in the checklists.</li>
<li>Application will be notified about the result of ICE connectivity checks via the callback that was given in <a class="el" href="group__PJNATH__ICE__SESSION.htm#ga68627f100f7a316645ca534e18a5477d">pj_ice_sess_create()</a> above.</li>
</ul>
<p>To send data, application calls <a class="el" href="group__PJNATH__ICE__SESSION.htm#gafadfb77d6a0cff9434f8d6a9943a803e">pj_ice_sess_send_data()</a>. If ICE negotiation has not completed, ICE session would simply drop the data, and return error to caller. If ICE negotiation has completed successfully, ICE session will in turn call the <em>on_tx_pkt</em> callback of <a class="el" href="structpj__ice__sess__cb.htm">pj_ice_sess_cb</a> instance that was previously registered in <a class="el" href="group__PJNATH__ICE__SESSION.htm#ga68627f100f7a316645ca534e18a5477d">pj_ice_sess_create()</a> above.</p>
<p>When application receives any packets on the underlying sockets, it must call <a class="el" href="group__PJNATH__ICE__SESSION.htm#ga27c9da6a420cd0d1c8a3e2fd7136165f">pj_ice_sess_on_rx_pkt()</a>. The ICE session will inspect the packet to decide whether to process it locally (if the packet is a STUN message and is part of ICE session) or otherwise pass it back to application via <em>on_rx_data</em> callback. </p>
<hr/><h2>Enumeration Type Documentation</h2>
<a class="anchor" id="gaf1efc18bd5354bbb7e31f2d538590195"></a><!-- doxytag: member="ice_session.h::pj_ice_cand_type" ref="gaf1efc18bd5354bbb7e31f2d538590195" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__PJNATH__ICE__SESSION.htm#gaf1efc18bd5354bbb7e31f2d538590195">pj_ice_cand_type</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This enumeration describes the type of an ICE candidate. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="ggaf1efc18bd5354bbb7e31f2d538590195ab0d5685346080516dfd851b7d795da4a"></a><!-- doxytag: member="PJ_ICE_CAND_TYPE_HOST" ref="ggaf1efc18bd5354bbb7e31f2d538590195ab0d5685346080516dfd851b7d795da4a" args="" -->PJ_ICE_CAND_TYPE_HOST</em>&nbsp;</td><td>
<p>ICE host candidate. A host candidate represents the actual local transport address in the host. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggaf1efc18bd5354bbb7e31f2d538590195ab1b228669c93311321c56d7ffcd3720a"></a><!-- doxytag: member="PJ_ICE_CAND_TYPE_SRFLX" ref="ggaf1efc18bd5354bbb7e31f2d538590195ab1b228669c93311321c56d7ffcd3720a" args="" -->PJ_ICE_CAND_TYPE_SRFLX</em>&nbsp;</td><td>
<p>ICE server reflexive candidate, which represents the public mapped address of the local address, and is obtained by sending STUN Binding request from the host candidate to a STUN server. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggaf1efc18bd5354bbb7e31f2d538590195a781d3f8b892a5e8ef2e949e6b3f6ab6c"></a><!-- doxytag: member="PJ_ICE_CAND_TYPE_PRFLX" ref="ggaf1efc18bd5354bbb7e31f2d538590195a781d3f8b892a5e8ef2e949e6b3f6ab6c" args="" -->PJ_ICE_CAND_TYPE_PRFLX</em>&nbsp;</td><td>
<p>ICE peer reflexive candidate, which is the address as seen by peer agent during connectivity check. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggaf1efc18bd5354bbb7e31f2d538590195a175a194dc076f6c35fb7cd0a094e7207"></a><!-- doxytag: member="PJ_ICE_CAND_TYPE_RELAYED" ref="ggaf1efc18bd5354bbb7e31f2d538590195a175a194dc076f6c35fb7cd0a094e7207" args="" -->PJ_ICE_CAND_TYPE_RELAYED</em>&nbsp;</td><td>
<p>ICE relayed candidate, which represents the address allocated in TURN server. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggaf1efc18bd5354bbb7e31f2d538590195a0c5911b7351c658165203a8ac947cdea"></a><!-- doxytag: member="PJ_ICE_CAND_TYPE_MAX" ref="ggaf1efc18bd5354bbb7e31f2d538590195a0c5911b7351c658165203a8ac947cdea" args="" -->PJ_ICE_CAND_TYPE_MAX</em>&nbsp;</td><td>
<p>Number of defined ICE candidate types. </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="ga95e83706882f6df82253a96978cb9f95"></a><!-- doxytag: member="ice_session.h::pj_ice_sess_check_state" ref="ga95e83706882f6df82253a96978cb9f95" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__PJNATH__ICE__SESSION.htm#ga95e83706882f6df82253a96978cb9f95">pj_ice_sess_check_state</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This enumeration describes the state of ICE check. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="gga95e83706882f6df82253a96978cb9f95ad34f96adb70060d37d049821b0556c0a"></a><!-- doxytag: member="PJ_ICE_SESS_CHECK_STATE_FROZEN" ref="gga95e83706882f6df82253a96978cb9f95ad34f96adb70060d37d049821b0556c0a" args="" -->PJ_ICE_SESS_CHECK_STATE_FROZEN</em>&nbsp;</td><td>
<p>A check for this pair hasn't been performed, and it can't yet be performed until some other check succeeds, allowing this pair to unfreeze and move into the Waiting state. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga95e83706882f6df82253a96978cb9f95a35ebf5af4cab1aaac022cd7e8b950779"></a><!-- doxytag: member="PJ_ICE_SESS_CHECK_STATE_WAITING" ref="gga95e83706882f6df82253a96978cb9f95a35ebf5af4cab1aaac022cd7e8b950779" args="" -->PJ_ICE_SESS_CHECK_STATE_WAITING</em>&nbsp;</td><td>
<p>A check has not been performed for this pair, and can be performed as soon as it is the highest priority Waiting pair on the check list. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga95e83706882f6df82253a96978cb9f95a1035a80420eb534f29de5325fca6e65b"></a><!-- doxytag: member="PJ_ICE_SESS_CHECK_STATE_IN_PROGRESS" ref="gga95e83706882f6df82253a96978cb9f95a1035a80420eb534f29de5325fca6e65b" args="" -->PJ_ICE_SESS_CHECK_STATE_IN_PROGRESS</em>&nbsp;</td><td>
<p>A check has not been performed for this pair, and can be performed as soon as it is the highest priority Waiting pair on the check list. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga95e83706882f6df82253a96978cb9f95af2e8117b3e9bb9524ef8cacd6c4ddcbf"></a><!-- doxytag: member="PJ_ICE_SESS_CHECK_STATE_SUCCEEDED" ref="gga95e83706882f6df82253a96978cb9f95af2e8117b3e9bb9524ef8cacd6c4ddcbf" args="" -->PJ_ICE_SESS_CHECK_STATE_SUCCEEDED</em>&nbsp;</td><td>
<p>A check has not been performed for this pair, and can be performed as soon as it is the highest priority Waiting pair on the check list. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga95e83706882f6df82253a96978cb9f95a59d46061551f63bf01102724fc78a692"></a><!-- doxytag: member="PJ_ICE_SESS_CHECK_STATE_FAILED" ref="gga95e83706882f6df82253a96978cb9f95a59d46061551f63bf01102724fc78a692" args="" -->PJ_ICE_SESS_CHECK_STATE_FAILED</em>&nbsp;</td><td>
<p>A check for this pair was already done and failed, either never producing any response or producing an unrecoverable failure response. </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="ga19dac31520f06372af6b6f51dcf87067"></a><!-- doxytag: member="ice_session.h::pj_ice_sess_checklist_state" ref="ga19dac31520f06372af6b6f51dcf87067" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__PJNATH__ICE__SESSION.htm#ga19dac31520f06372af6b6f51dcf87067">pj_ice_sess_checklist_state</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This enumeration describes ICE checklist state. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="gga19dac31520f06372af6b6f51dcf87067a97d7a7f5a2a85c93fd4036dac777e58a"></a><!-- doxytag: member="PJ_ICE_SESS_CHECKLIST_ST_IDLE" ref="gga19dac31520f06372af6b6f51dcf87067a97d7a7f5a2a85c93fd4036dac777e58a" args="" -->PJ_ICE_SESS_CHECKLIST_ST_IDLE</em>&nbsp;</td><td>
<p>The checklist is not yet running. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga19dac31520f06372af6b6f51dcf87067a98f4119b8465605e66baad82cb4204c7"></a><!-- doxytag: member="PJ_ICE_SESS_CHECKLIST_ST_RUNNING" ref="gga19dac31520f06372af6b6f51dcf87067a98f4119b8465605e66baad82cb4204c7" args="" -->PJ_ICE_SESS_CHECKLIST_ST_RUNNING</em>&nbsp;</td><td>
<p>In this state, ICE checks are still in progress for this media stream. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga19dac31520f06372af6b6f51dcf87067a9720334d73272d58f466908b78187530"></a><!-- doxytag: member="PJ_ICE_SESS_CHECKLIST_ST_COMPLETED" ref="gga19dac31520f06372af6b6f51dcf87067a9720334d73272d58f466908b78187530" args="" -->PJ_ICE_SESS_CHECKLIST_ST_COMPLETED</em>&nbsp;</td><td>
<p>In this state, ICE checks have completed for this media stream, either successfully or with failure. </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="ga1d005022224e45654bcdef0eeafae217"></a><!-- doxytag: member="ice_session.h::pj_ice_sess_role" ref="ga1d005022224e45654bcdef0eeafae217" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__PJNATH__ICE__SESSION.htm#ga1d005022224e45654bcdef0eeafae217">pj_ice_sess_role</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This enumeration describes the role of the ICE agent. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="gga1d005022224e45654bcdef0eeafae217a1513fa3b134a0784bfab297f995c0f3e"></a><!-- doxytag: member="PJ_ICE_SESS_ROLE_UNKNOWN" ref="gga1d005022224e45654bcdef0eeafae217a1513fa3b134a0784bfab297f995c0f3e" args="" -->PJ_ICE_SESS_ROLE_UNKNOWN</em>&nbsp;</td><td>
<p>The role is unknown. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga1d005022224e45654bcdef0eeafae217adf65b85e5be9f6e1e22aa0e06c64476c"></a><!-- doxytag: member="PJ_ICE_SESS_ROLE_CONTROLLED" ref="gga1d005022224e45654bcdef0eeafae217adf65b85e5be9f6e1e22aa0e06c64476c" args="" -->PJ_ICE_SESS_ROLE_CONTROLLED</em>&nbsp;</td><td>
<p>The ICE agent is in controlled role. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga1d005022224e45654bcdef0eeafae217a5b0145b939df96bee579f4d368203b8c"></a><!-- doxytag: member="PJ_ICE_SESS_ROLE_CONTROLLING" ref="gga1d005022224e45654bcdef0eeafae217a5b0145b939df96bee579f4d368203b8c" args="" -->PJ_ICE_SESS_ROLE_CONTROLLING</em>&nbsp;</td><td>
<p>The ICE agent is in controlling role. </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="gaaf86099f9ea896cafadceaa223b929a6"></a><!-- doxytag: member="ice_session.h::pj_ice_calc_foundation" ref="gaaf86099f9ea896cafadceaa223b929a6" args="(pj_pool_t *pool, pj_str_t *foundation, pj_ice_cand_type type, const pj_sockaddr *base_addr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__PJNATH__ICE__SESSION.htm#gaaf86099f9ea896cafadceaa223b929a6">pj_ice_calc_foundation</a> </td>
          <td>(</td>
          <td class="paramtype">pj_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pj_str_t *&#160;</td>
          <td class="paramname"><em>foundation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PJNATH__ICE__SESSION.htm#gaf1efc18bd5354bbb7e31f2d538590195">pj_ice_cand_type</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const pj_sockaddr *&#160;</td>
          <td class="paramname"><em>base_addr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This is a utility function to calculate the foundation identification for a candidate.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pool</td><td>Pool to allocate the foundation string. </td></tr>
    <tr><td class="paramname">foundation</td><td>Pointer to receive the foundation string. </td></tr>
    <tr><td class="paramname">type</td><td>Candidate type. </td></tr>
    <tr><td class="paramname">base_addr</td><td>Base address of the candidate. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga18fd89ecc361d0d0282b856ef62814c1"></a><!-- doxytag: member="ice_session.h::pj_ice_get_cand_type_name" ref="ga18fd89ecc361d0d0282b856ef62814c1" args="(pj_ice_cand_type type)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* <a class="el" href="group__PJNATH__ICE__SESSION.htm#ga18fd89ecc361d0d0282b856ef62814c1">pj_ice_get_cand_type_name</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__PJNATH__ICE__SESSION.htm#gaf1efc18bd5354bbb7e31f2d538590195">pj_ice_cand_type</a>&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This is a utility function to retrieve the string name for the particular candidate type.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>Candidate type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The string representation of the candidate type. </dd></dl>

</div>
</div>
<a class="anchor" id="gaca953988f0f3a0580c189218996b7ece"></a><!-- doxytag: member="ice_session.h::pj_ice_sess_add_cand" ref="gaca953988f0f3a0580c189218996b7ece" args="(pj_ice_sess *ice, unsigned comp_id, unsigned transport_id, pj_ice_cand_type type, pj_uint16_t local_pref, const pj_str_t *foundation, const pj_sockaddr_t *addr, const pj_sockaddr_t *base_addr, const pj_sockaddr_t *rel_addr, int addr_len, unsigned *p_cand_id)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pj_status_t <a class="el" href="group__PJNATH__ICE__SESSION.htm#gaca953988f0f3a0580c189218996b7ece">pj_ice_sess_add_cand</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpj__ice__sess.htm">pj_ice_sess</a> *&#160;</td>
          <td class="paramname"><em>ice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>comp_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>transport_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PJNATH__ICE__SESSION.htm#gaf1efc18bd5354bbb7e31f2d538590195">pj_ice_cand_type</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pj_uint16_t&#160;</td>
          <td class="paramname"><em>local_pref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const pj_str_t *&#160;</td>
          <td class="paramname"><em>foundation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const pj_sockaddr_t *&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const pj_sockaddr_t *&#160;</td>
          <td class="paramname"><em>base_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const pj_sockaddr_t *&#160;</td>
          <td class="paramname"><em>rel_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>addr_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned *&#160;</td>
          <td class="paramname"><em>p_cand_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Add a candidate to this ICE session. Application must add candidates for each components ID before it can start pairing the candidates and performing connectivity checks.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">ice</td><td>ICE session instance. </td></tr>
    <tr><td class="paramname">comp_id</td><td>Component ID of this candidate. </td></tr>
    <tr><td class="paramname">transport_id</td><td>Transport ID to be used to send packets for this candidate. </td></tr>
    <tr><td class="paramname">type</td><td>Candidate type. </td></tr>
    <tr><td class="paramname">local_pref</td><td>Local preference for this candidate, which normally should be set to 65535. </td></tr>
    <tr><td class="paramname">foundation</td><td>Foundation identification. </td></tr>
    <tr><td class="paramname">addr</td><td>The candidate address. </td></tr>
    <tr><td class="paramname">base_addr</td><td>The candidate's base address. </td></tr>
    <tr><td class="paramname">rel_addr</td><td>Optional related address. </td></tr>
    <tr><td class="paramname">addr_len</td><td>Length of addresses. </td></tr>
    <tr><td class="paramname">p_cand_id</td><td>Optional pointer to receive the candidate ID.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>PJ_SUCCESS if candidate is successfully added. </dd></dl>

</div>
</div>
<a class="anchor" id="ga8e8c53cb47d14494080a93715b185480"></a><!-- doxytag: member="ice_session.h::pj_ice_sess_change_role" ref="ga8e8c53cb47d14494080a93715b185480" args="(pj_ice_sess *ice, pj_ice_sess_role new_role)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pj_status_t <a class="el" href="group__PJNATH__ICE__SESSION.htm#ga8e8c53cb47d14494080a93715b185480">pj_ice_sess_change_role</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpj__ice__sess.htm">pj_ice_sess</a> *&#160;</td>
          <td class="paramname"><em>ice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PJNATH__ICE__SESSION.htm#ga1d005022224e45654bcdef0eeafae217">pj_ice_sess_role</a>&#160;</td>
          <td class="paramname"><em>new_role</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Change session role. This happens for example when ICE session was created with controlled role when receiving an offer, but it turns out that the offer contains "a=ice-lite" attribute when the SDP gets inspected.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">ice</td><td>The ICE session. </td></tr>
    <tr><td class="paramname">new_role</td><td>The new role to be set.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>PJ_SUCCESS on success, or the appropriate error. </dd></dl>

</div>
</div>
<a class="anchor" id="ga68627f100f7a316645ca534e18a5477d"></a><!-- doxytag: member="ice_session.h::pj_ice_sess_create" ref="ga68627f100f7a316645ca534e18a5477d" args="(pj_stun_config *stun_cfg, const char *name, pj_ice_sess_role role, unsigned comp_cnt, const pj_ice_sess_cb *cb, const pj_str_t *local_ufrag, const pj_str_t *local_passwd, pj_grp_lock_t *grp_lock, pj_ice_sess **p_ice)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pj_status_t <a class="el" href="group__PJNATH__ICE__SESSION.htm#ga68627f100f7a316645ca534e18a5477d">pj_ice_sess_create</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpj__stun__config.htm">pj_stun_config</a> *&#160;</td>
          <td class="paramname"><em>stun_cfg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PJNATH__ICE__SESSION.htm#ga1d005022224e45654bcdef0eeafae217">pj_ice_sess_role</a>&#160;</td>
          <td class="paramname"><em>role</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>comp_cnt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpj__ice__sess__cb.htm">pj_ice_sess_cb</a> *&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const pj_str_t *&#160;</td>
          <td class="paramname"><em>local_ufrag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const pj_str_t *&#160;</td>
          <td class="paramname"><em>local_passwd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pj_grp_lock_t *&#160;</td>
          <td class="paramname"><em>grp_lock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpj__ice__sess.htm">pj_ice_sess</a> **&#160;</td>
          <td class="paramname"><em>p_ice</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create ICE session with the specified role and number of components. Application would typically need to create an ICE session before sending an offer or upon receiving one. After the session is created, application can register candidates to the ICE session by calling <a class="el" href="group__PJNATH__ICE__SESSION.htm#gaca953988f0f3a0580c189218996b7ece">pj_ice_sess_add_cand()</a> function.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">stun_cfg</td><td>The STUN configuration settings, containing among other things the timer heap instance to be used by the ICE session. </td></tr>
    <tr><td class="paramname">name</td><td>Optional name to identify this ICE instance in the log file. </td></tr>
    <tr><td class="paramname">role</td><td>ICE role. </td></tr>
    <tr><td class="paramname">comp_cnt</td><td>Number of components. </td></tr>
    <tr><td class="paramname">cb</td><td>ICE callback. </td></tr>
    <tr><td class="paramname">local_ufrag</td><td>Optional string to be used as local username to authenticate incoming STUN binding request. If the value is NULL, a random string will be generated. </td></tr>
    <tr><td class="paramname">local_passwd</td><td>Optional string to be used as local password. </td></tr>
    <tr><td class="paramname">grp_lock</td><td>Optional group lock to be used by this session. If NULL, the session will create one itself. </td></tr>
    <tr><td class="paramname">p_ice</td><td>Pointer to receive the ICE session instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>PJ_SUCCESS if ICE session is created successfully. </dd></dl>

</div>
</div>
<a class="anchor" id="gaf8efccb541d729c38fb975d1f56fb3f8"></a><!-- doxytag: member="ice_session.h::pj_ice_sess_create_check_list" ref="gaf8efccb541d729c38fb975d1f56fb3f8" args="(pj_ice_sess *ice, const pj_str_t *rem_ufrag, const pj_str_t *rem_passwd, unsigned rem_cand_cnt, const pj_ice_sess_cand rem_cand[])" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pj_status_t <a class="el" href="group__PJNATH__ICE__SESSION.htm#gaf8efccb541d729c38fb975d1f56fb3f8">pj_ice_sess_create_check_list</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpj__ice__sess.htm">pj_ice_sess</a> *&#160;</td>
          <td class="paramname"><em>ice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const pj_str_t *&#160;</td>
          <td class="paramname"><em>rem_ufrag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const pj_str_t *&#160;</td>
          <td class="paramname"><em>rem_passwd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>rem_cand_cnt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpj__ice__sess__cand.htm">pj_ice_sess_cand</a>&#160;</td>
          <td class="paramname"><em>rem_cand</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Pair the local and remote candidates to create check list. Application typically would call this function after receiving SDP containing ICE candidates from the remote host (either upon receiving the initial offer, for UAS, or upon receiving the answer, for UAC).</p>
<p>Note that ICE connectivity check will not start until application calls <a class="el" href="group__PJNATH__ICE__SESSION.htm#ga9f65ac601ea1b86ef2b17fa4c7ef902a">pj_ice_sess_start_check()</a>.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">ice</td><td>ICE session instance. </td></tr>
    <tr><td class="paramname">rem_ufrag</td><td>Remote ufrag, as seen in the SDP received from the remote agent. </td></tr>
    <tr><td class="paramname">rem_passwd</td><td>Remote password, as seen in the SDP received from the remote agent. </td></tr>
    <tr><td class="paramname">rem_cand_cnt</td><td>Number of remote candidates. </td></tr>
    <tr><td class="paramname">rem_cand</td><td>Remote candidate array. Remote candidates are gathered from the SDP received from the remote agent.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>PJ_SUCCESS or the appropriate error code. </dd></dl>

</div>
</div>
<a class="anchor" id="gac96792c078b5d9eed6f20d0747a291f0"></a><!-- doxytag: member="ice_session.h::pj_ice_sess_destroy" ref="gac96792c078b5d9eed6f20d0747a291f0" args="(pj_ice_sess *ice)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pj_status_t <a class="el" href="group__PJNATH__ICE__SESSION.htm#gac96792c078b5d9eed6f20d0747a291f0">pj_ice_sess_destroy</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpj__ice__sess.htm">pj_ice_sess</a> *&#160;</td>
          <td class="paramname"><em>ice</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Destroy ICE session. This will cancel any connectivity checks currently running, if any, and any other events scheduled by this session, as well as all memory resources.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">ice</td><td>ICE session instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>PJ_SUCCESS on success. </dd></dl>

</div>
</div>
<a class="anchor" id="gacd6f2284b80728cf3077a6dc007b5911"></a><!-- doxytag: member="ice_session.h::pj_ice_sess_find_default_cand" ref="gacd6f2284b80728cf3077a6dc007b5911" args="(pj_ice_sess *ice, unsigned comp_id, int *p_cand_id)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pj_status_t <a class="el" href="group__PJNATH__ICE__SESSION.htm#gacd6f2284b80728cf3077a6dc007b5911">pj_ice_sess_find_default_cand</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpj__ice__sess.htm">pj_ice_sess</a> *&#160;</td>
          <td class="paramname"><em>ice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>comp_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>p_cand_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Find default candidate for the specified component ID, using this rule:</p>
<ul>
<li>if the component has a successful candidate pair, then the local candidate of this pair will be returned.</li>
<li>otherwise a relay, reflexive, or host candidate will be selected on that specified order.</li>
</ul>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">ice</td><td>The ICE session instance. </td></tr>
    <tr><td class="paramname">comp_id</td><td>The component ID. </td></tr>
    <tr><td class="paramname">p_cand_id</td><td>Pointer to receive the candidate ID.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>PJ_SUCCESS if a candidate has been selected. </dd></dl>

</div>
</div>
<a class="anchor" id="gaf49d920b20f3d0f8833531cb98a7fb84"></a><!-- doxytag: member="ice_session.h::pj_ice_sess_get_options" ref="gaf49d920b20f3d0f8833531cb98a7fb84" args="(pj_ice_sess *ice, pj_ice_sess_options *opt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pj_status_t <a class="el" href="group__PJNATH__ICE__SESSION.htm#gaf49d920b20f3d0f8833531cb98a7fb84">pj_ice_sess_get_options</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpj__ice__sess.htm">pj_ice_sess</a> *&#160;</td>
          <td class="paramname"><em>ice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpj__ice__sess__options.htm">pj_ice_sess_options</a> *&#160;</td>
          <td class="paramname"><em>opt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get the value of various options of the ICE session.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">ice</td><td>The ICE session. </td></tr>
    <tr><td class="paramname">opt</td><td>The options to be initialized with the values from the ICE session.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>PJ_SUCCESS on success, or the appropriate error. </dd></dl>

</div>
</div>
<a class="anchor" id="ga27c9da6a420cd0d1c8a3e2fd7136165f"></a><!-- doxytag: member="ice_session.h::pj_ice_sess_on_rx_pkt" ref="ga27c9da6a420cd0d1c8a3e2fd7136165f" args="(pj_ice_sess *ice, unsigned comp_id, unsigned transport_id, void *pkt, pj_size_t pkt_size, const pj_sockaddr_t *src_addr, int src_addr_len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pj_status_t <a class="el" href="group__PJNATH__ICE__SESSION.htm#ga27c9da6a420cd0d1c8a3e2fd7136165f">pj_ice_sess_on_rx_pkt</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpj__ice__sess.htm">pj_ice_sess</a> *&#160;</td>
          <td class="paramname"><em>ice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>comp_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>transport_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pkt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pj_size_t&#160;</td>
          <td class="paramname"><em>pkt_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const pj_sockaddr_t *&#160;</td>
          <td class="paramname"><em>src_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>src_addr_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Report the arrival of packet to the ICE session. Since ICE session itself doesn't have any transports, it relies on application or higher layer component to give incoming packets to the ICE session. If the packet is not a STUN packet, this packet will be given back to application via <em>on_rx_data()</em> callback in <a class="el" href="structpj__ice__sess__cb.htm">pj_ice_sess_cb</a>.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">ice</td><td>The ICE session. </td></tr>
    <tr><td class="paramname">comp_id</td><td>Component ID. </td></tr>
    <tr><td class="paramname">transport_id</td><td>Number to identify where this packet was received from. This parameter will be returned back to application in <em>on_tx_pkt()</em> callback. </td></tr>
    <tr><td class="paramname">pkt</td><td>Incoming packet. </td></tr>
    <tr><td class="paramname">pkt_size</td><td>Size of incoming packet. </td></tr>
    <tr><td class="paramname">src_addr</td><td>Source address of the packet. </td></tr>
    <tr><td class="paramname">src_addr_len</td><td>Length of the address.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>PJ_SUCCESS or the appropriate error code. </dd></dl>

</div>
</div>
<a class="anchor" id="ga3a7278988931dd6ab04c10d6d936e972"></a><!-- doxytag: member="ice_session.h::pj_ice_sess_options_default" ref="ga3a7278988931dd6ab04c10d6d936e972" args="(pj_ice_sess_options *opt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__PJNATH__ICE__SESSION.htm#ga3a7278988931dd6ab04c10d6d936e972">pj_ice_sess_options_default</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpj__ice__sess__options.htm">pj_ice_sess_options</a> *&#160;</td>
          <td class="paramname"><em>opt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Initialize ICE session options with library default values.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">opt</td><td>ICE session options. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga06cb4ce81895ab34f06943ae30860f1a"></a><!-- doxytag: member="ice_session.h::pj_ice_sess_role_name" ref="ga06cb4ce81895ab34f06943ae30860f1a" args="(pj_ice_sess_role role)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* <a class="el" href="group__PJNATH__ICE__SESSION.htm#ga06cb4ce81895ab34f06943ae30860f1a">pj_ice_sess_role_name</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__PJNATH__ICE__SESSION.htm#ga1d005022224e45654bcdef0eeafae217">pj_ice_sess_role</a>&#160;</td>
          <td class="paramname"><em>role</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This is a utility function to retrieve the string name for the particular role type.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">role</td><td>Role type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The string representation of the role. </dd></dl>

</div>
</div>
<a class="anchor" id="gafadfb77d6a0cff9434f8d6a9943a803e"></a><!-- doxytag: member="ice_session.h::pj_ice_sess_send_data" ref="gafadfb77d6a0cff9434f8d6a9943a803e" args="(pj_ice_sess *ice, unsigned comp_id, const void *data, pj_size_t data_len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pj_status_t <a class="el" href="group__PJNATH__ICE__SESSION.htm#gafadfb77d6a0cff9434f8d6a9943a803e">pj_ice_sess_send_data</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpj__ice__sess.htm">pj_ice_sess</a> *&#160;</td>
          <td class="paramname"><em>ice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>comp_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pj_size_t&#160;</td>
          <td class="paramname"><em>data_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Send data using this ICE session. If ICE checks have not produced a valid check for the specified component ID, this function will return with failure. Otherwise ICE session will send the packet to remote destination using the nominated local candidate for the specified component.</p>
<p>This function will in turn call <em>on_tx_pkt</em> function in <a class="el" href="structpj__ice__sess__cb.htm">pj_ice_sess_cb</a> callback to actually send the packet to the wire.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">ice</td><td>The ICE session. </td></tr>
    <tr><td class="paramname">comp_id</td><td>Component ID. </td></tr>
    <tr><td class="paramname">data</td><td>The data or packet to be sent. </td></tr>
    <tr><td class="paramname">data_len</td><td>Size of data or packet, in bytes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>PJ_SUCCESS if data is sent successfully. </dd></dl>

</div>
</div>
<a class="anchor" id="ga0c61188a773832277c8559fe0713946f"></a><!-- doxytag: member="ice_session.h::pj_ice_sess_set_options" ref="ga0c61188a773832277c8559fe0713946f" args="(pj_ice_sess *ice, const pj_ice_sess_options *opt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pj_status_t <a class="el" href="group__PJNATH__ICE__SESSION.htm#ga0c61188a773832277c8559fe0713946f">pj_ice_sess_set_options</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpj__ice__sess.htm">pj_ice_sess</a> *&#160;</td>
          <td class="paramname"><em>ice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpj__ice__sess__options.htm">pj_ice_sess_options</a> *&#160;</td>
          <td class="paramname"><em>opt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Specify various options for this ICE session. Application MUST only call this function after the ICE session has been created but before any connectivity check is started.</p>
<p>Application should call <a class="el" href="group__PJNATH__ICE__SESSION.htm#gaf49d920b20f3d0f8833531cb98a7fb84">pj_ice_sess_get_options()</a> to initialize the options with their default values.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">ice</td><td>The ICE session. </td></tr>
    <tr><td class="paramname">opt</td><td>Options to be applied to the ICE session.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>PJ_SUCCESS on success, or the appropriate error. </dd></dl>

</div>
</div>
<a class="anchor" id="ga819f43e9f3690174c3f0f011b2ad8e9e"></a><!-- doxytag: member="ice_session.h::pj_ice_sess_set_prefs" ref="ga819f43e9f3690174c3f0f011b2ad8e9e" args="(pj_ice_sess *ice, const pj_uint8_t prefs[4])" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pj_status_t <a class="el" href="group__PJNATH__ICE__SESSION.htm#ga819f43e9f3690174c3f0f011b2ad8e9e">pj_ice_sess_set_prefs</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpj__ice__sess.htm">pj_ice_sess</a> *&#160;</td>
          <td class="paramname"><em>ice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const pj_uint8_t&#160;</td>
          <td class="paramname"><em>prefs</em>[4]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Assign a custom preference values for ICE candidate types. By assigning custom preference value, application can control the order of candidates to be checked first. The default preference settings is to use 126 for host candidates, 100 for server reflexive candidates, 110 for peer reflexive candidates, an 0 for relayed candidates.</p>
<p>Note that this function must be called before any candidates are added to the ICE session.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">ice</td><td>The ICE session. </td></tr>
    <tr><td class="paramname">prefs</td><td>Array of candidate preference value. The values are put in the array indexed by the candidate type as specified in pj_ice_cand_type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>PJ_SUCCESS on success, or the appropriate error code. </dd></dl>

</div>
</div>
<a class="anchor" id="ga9f65ac601ea1b86ef2b17fa4c7ef902a"></a><!-- doxytag: member="ice_session.h::pj_ice_sess_start_check" ref="ga9f65ac601ea1b86ef2b17fa4c7ef902a" args="(pj_ice_sess *ice)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pj_status_t <a class="el" href="group__PJNATH__ICE__SESSION.htm#ga9f65ac601ea1b86ef2b17fa4c7ef902a">pj_ice_sess_start_check</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpj__ice__sess.htm">pj_ice_sess</a> *&#160;</td>
          <td class="paramname"><em>ice</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Start ICE periodic check. This function will return immediately, and application will be notified about the connectivity check status in <a class="el" href="structpj__ice__sess__cb.htm">pj_ice_sess_cb</a> callback.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">ice</td><td>The ICE session instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>PJ_SUCCESS or the appropriate error code. </dd></dl>

</div>
</div>
</div><!-- contents -->
	</TD></TD></TABLE>
<p>&nbsp;</p>
<hr><center>
PJNATH - Open Source NAT traversal helper library supporting STUN, TURN, and ICE<br>
Copyright (C) 2006-2009 Teluu Inc.
</center>


<!--#include virtual="/footer.html" -->

</BODY>
</HTML>
