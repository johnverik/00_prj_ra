<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>TURN client session (2.4)</title>
<link href="/style/style.css" rel="stylesheet" type="text/css">
</head><body>
	<!--#include virtual="/header.html" -->
	<TABLE border=0 width="90%"><TR><TD>
	<p><A HREF="/">Home</A> --&gt; <A HREF="/docs.htm">Documentations</A> --&gt; <A HREF="/pjnath/docs/html/index.htm">PJNATH Reference</A></p>


<!-- Generated by Doxygen 1.7.6.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.htm"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.htm"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.htm"><span>Modules</span></a></li>
      <li><a href="annotated.htm"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.htm"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">TURN client session</div>  </div>
<div class="ingroups"><a class="el" href="group__PJNATH__TURN.htm">TURN: Traversal Using Relays around NAT</a></div></div><!--header-->
<div class="contents">

<p>Transport independent TURN client session.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpj__turn__channel__data.htm">pj_turn_channel_data</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpj__turn__session__cb.htm">pj_turn_session_cb</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpj__turn__alloc__param.htm">pj_turn_alloc_param</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpj__turn__session__info.htm">pj_turn_session_info</a></td></tr>
<tr><td colspan="2"><h2><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="group__PJNATH__TURN__SESSION.htm#ga6b1aed7eb13119538d38728b02ef6c83">pj_turn_session</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJNATH__TURN__SESSION.htm#ga6b1aed7eb13119538d38728b02ef6c83">pj_turn_session</a></td></tr>
<tr><td colspan="2"><h2><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJNATH__TURN__SESSION.htm#ga0dfed6bb5edc5fe18950a46da5ff591e">pj_turn_tp_type</a> { <br/>
&#160;&#160;<a class="el" href="group__PJNATH__TURN__SESSION.htm#gga0dfed6bb5edc5fe18950a46da5ff591ea863d21c16c6678359201dda47a7712d5">PJ_TURN_TP_UDP</a> =  17, 
<br/>
&#160;&#160;<a class="el" href="group__PJNATH__TURN__SESSION.htm#gga0dfed6bb5edc5fe18950a46da5ff591ea060378594a0fcb19a419d3e71614f449">PJ_TURN_TP_TCP</a> =  6, 
<br/>
&#160;&#160;<a class="el" href="group__PJNATH__TURN__SESSION.htm#gga0dfed6bb5edc5fe18950a46da5ff591eae461ce18021d349208f36d9553e93226">PJ_TURN_TP_TLS</a> =  255
<br/>
 }</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJNATH__TURN__SESSION.htm#ga763f751e1663de5a61b9e9013541530d">pj_turn_state_t</a> { <br/>
&#160;&#160;<a class="el" href="group__PJNATH__TURN__SESSION.htm#gga763f751e1663de5a61b9e9013541530da26f5e0dba9aaf21f3066102652dabca3">PJ_TURN_STATE_NULL</a>, 
<br/>
&#160;&#160;<a class="el" href="group__PJNATH__TURN__SESSION.htm#gga763f751e1663de5a61b9e9013541530da3777036805c19f0a4a482028d31953ae">PJ_TURN_STATE_RESOLVING</a>, 
<br/>
&#160;&#160;<a class="el" href="group__PJNATH__TURN__SESSION.htm#gga763f751e1663de5a61b9e9013541530dac8685cb2b1415fb0eef0c46eb73224ac">PJ_TURN_STATE_RESOLVED</a>, 
<br/>
&#160;&#160;<a class="el" href="group__PJNATH__TURN__SESSION.htm#gga763f751e1663de5a61b9e9013541530da7d184e0b189d3d3831a109ac6e4cfe3b">PJ_TURN_STATE_ALLOCATING</a>, 
<br/>
&#160;&#160;<a class="el" href="group__PJNATH__TURN__SESSION.htm#gga763f751e1663de5a61b9e9013541530da9d5c96a0383c6401ec06596a6df50a04">PJ_TURN_STATE_READY</a>, 
<br/>
&#160;&#160;<a class="el" href="group__PJNATH__TURN__SESSION.htm#gga763f751e1663de5a61b9e9013541530dab4282c3b4422839d6ab1ffc18e751ce3">PJ_TURN_STATE_DEALLOCATING</a>, 
<br/>
&#160;&#160;<a class="el" href="group__PJNATH__TURN__SESSION.htm#gga763f751e1663de5a61b9e9013541530da5a387f364ae3125b72ba8ab205a0cf2c">PJ_TURN_STATE_DEALLOCATED</a>, 
<br/>
&#160;&#160;<a class="el" href="group__PJNATH__TURN__SESSION.htm#gga763f751e1663de5a61b9e9013541530dab9e29e0ce5f91e5c91acf58054303fbf">PJ_TURN_STATE_DESTROYING</a>
<br/>
 }</td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJNATH__TURN__SESSION.htm#gacf9769bbe27bd7c5138cf7dce13c5d26">pj_turn_alloc_param_default</a> (<a class="el" href="structpj__turn__alloc__param.htm">pj_turn_alloc_param</a> *prm)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJNATH__TURN__SESSION.htm#ga7807ca242062938a51d3a626a936a675">pj_turn_alloc_param_copy</a> (pj_pool_t *pool, <a class="el" href="structpj__turn__alloc__param.htm">pj_turn_alloc_param</a> *dst, const <a class="el" href="structpj__turn__alloc__param.htm">pj_turn_alloc_param</a> *src)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJNATH__TURN__SESSION.htm#ga9f1e11aa8d185d8c383b64fcbd24ce95">pj_turn_state_name</a> (<a class="el" href="group__PJNATH__TURN__SESSION.htm#ga763f751e1663de5a61b9e9013541530d">pj_turn_state_t</a> state)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">pj_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJNATH__TURN__SESSION.htm#ga54f3cbdf472ffcbb0b5ffb7fda2a7191">pj_turn_session_create</a> (const <a class="el" href="structpj__stun__config.htm">pj_stun_config</a> *cfg, const char *name, int af, <a class="el" href="group__PJNATH__TURN__SESSION.htm#ga0dfed6bb5edc5fe18950a46da5ff591e">pj_turn_tp_type</a> conn_type, pj_grp_lock_t *grp_lock, const <a class="el" href="structpj__turn__session__cb.htm">pj_turn_session_cb</a> *cb, unsigned options, void *user_data, <a class="el" href="group__PJNATH__TURN__SESSION.htm#ga6b1aed7eb13119538d38728b02ef6c83">pj_turn_session</a> **p_sess)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">pj_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJNATH__TURN__SESSION.htm#ga3f97ccb740c68be36698800209761043">pj_turn_session_shutdown</a> (<a class="el" href="group__PJNATH__TURN__SESSION.htm#ga6b1aed7eb13119538d38728b02ef6c83">pj_turn_session</a> *sess)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">pj_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJNATH__TURN__SESSION.htm#ga6128f788c801e8cebdc259da48506b4f">pj_turn_session_destroy</a> (<a class="el" href="group__PJNATH__TURN__SESSION.htm#ga6b1aed7eb13119538d38728b02ef6c83">pj_turn_session</a> *sess, pj_status_t last_err)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">pj_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJNATH__TURN__SESSION.htm#ga2ceac5ff7523f578f17cbf93b283d411">pj_turn_session_get_info</a> (<a class="el" href="group__PJNATH__TURN__SESSION.htm#ga6b1aed7eb13119538d38728b02ef6c83">pj_turn_session</a> *sess, <a class="el" href="structpj__turn__session__info.htm">pj_turn_session_info</a> *info)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">pj_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJNATH__TURN__SESSION.htm#ga5e2ebb2697547d4805a0c661dce11fa1">pj_turn_session_set_user_data</a> (<a class="el" href="group__PJNATH__TURN__SESSION.htm#ga6b1aed7eb13119538d38728b02ef6c83">pj_turn_session</a> *sess, void *user_data)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJNATH__TURN__SESSION.htm#ga509471fc6f2030508c6738ac14ace715">pj_turn_session_get_user_data</a> (<a class="el" href="group__PJNATH__TURN__SESSION.htm#ga6b1aed7eb13119538d38728b02ef6c83">pj_turn_session</a> *sess)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">pj_grp_lock_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJNATH__TURN__SESSION.htm#gad0ebf44a71855b18c9bdf8cb2ff25685">pj_turn_session_get_grp_lock</a> (<a class="el" href="group__PJNATH__TURN__SESSION.htm#ga6b1aed7eb13119538d38728b02ef6c83">pj_turn_session</a> *sess)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJNATH__TURN__SESSION.htm#ga55ec6f5761918be38ade94b2ae3fdcf1">pj_turn_session_set_log</a> (<a class="el" href="group__PJNATH__TURN__SESSION.htm#ga6b1aed7eb13119538d38728b02ef6c83">pj_turn_session</a> *sess, unsigned flags)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">pj_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJNATH__TURN__SESSION.htm#ga0737f8c0be3719df43794ce16aa84356">pj_turn_session_set_software_name</a> (<a class="el" href="group__PJNATH__TURN__SESSION.htm#ga6b1aed7eb13119538d38728b02ef6c83">pj_turn_session</a> *sess, const pj_str_t *sw)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">pj_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJNATH__TURN__SESSION.htm#ga6bdcca67965ac43d3b7cd79b99a38278">pj_turn_session_set_server</a> (<a class="el" href="group__PJNATH__TURN__SESSION.htm#ga6b1aed7eb13119538d38728b02ef6c83">pj_turn_session</a> *sess, const pj_str_t *domain, int default_port, pj_dns_resolver *resolver)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">pj_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJNATH__TURN__SESSION.htm#ga30e58bdcfa5e3558f359aaee21d9dca5">pj_turn_session_set_credential</a> (<a class="el" href="group__PJNATH__TURN__SESSION.htm#ga6b1aed7eb13119538d38728b02ef6c83">pj_turn_session</a> *sess, const <a class="el" href="structpj__stun__auth__cred.htm">pj_stun_auth_cred</a> *cred)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">pj_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJNATH__TURN__SESSION.htm#ga168d6661649020978826cea53f211b11">pj_turn_session_alloc</a> (<a class="el" href="group__PJNATH__TURN__SESSION.htm#ga6b1aed7eb13119538d38728b02ef6c83">pj_turn_session</a> *sess, const <a class="el" href="structpj__turn__alloc__param.htm">pj_turn_alloc_param</a> *param)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">pj_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJNATH__TURN__SESSION.htm#ga0d44a18b6923a0dd760947880ca08646">pj_turn_session_set_perm</a> (<a class="el" href="group__PJNATH__TURN__SESSION.htm#ga6b1aed7eb13119538d38728b02ef6c83">pj_turn_session</a> *sess, unsigned addr_cnt, const pj_sockaddr addr[], unsigned options)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">pj_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJNATH__TURN__SESSION.htm#gaefe8e88c0511df20874a1195527d988a">pj_turn_session_sendto</a> (<a class="el" href="group__PJNATH__TURN__SESSION.htm#ga6b1aed7eb13119538d38728b02ef6c83">pj_turn_session</a> *sess, const pj_uint8_t *pkt, unsigned pkt_len, const pj_sockaddr_t *peer_addr, unsigned addr_len)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">pj_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJNATH__TURN__SESSION.htm#ga495c8306ed948c1ac713bfad27151a17">pj_turn_session_bind_channel</a> (<a class="el" href="group__PJNATH__TURN__SESSION.htm#ga6b1aed7eb13119538d38728b02ef6c83">pj_turn_session</a> *sess, const pj_sockaddr_t *peer, unsigned addr_len)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">pj_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PJNATH__TURN__SESSION.htm#ga18dd1819995d6a98fdf67f1a56b5ac5f">pj_turn_session_on_rx_pkt</a> (<a class="el" href="group__PJNATH__TURN__SESSION.htm#ga6b1aed7eb13119538d38728b02ef6c83">pj_turn_session</a> *sess, void *pkt, pj_size_t pkt_len, pj_size_t *parsed_len)</td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<p>The <a class="el" href="group__PJNATH__TURN__SESSION.htm">TURN client session</a> is a transport-independent object to manage a client TURN session. It contains the core logic for manage the TURN client session as listed in <a class="el" href="group__PJNATH__TURN.htm#turn_op_sec">Overview of TURN operations</a>, but in transport-independent manner (i.e. it doesn't have a socket), so that developer can integrate TURN client functionality into existing framework that already has its own means to send and receive data, or to support new transport types to TURN, such as TLS.</p>
<h2><a class="anchor" id="turn_sess_using_sec"></a>
Using the TURN session</h2>
<p>These steps describes how to use the TURN session:</p>
<ul>
<li><b>Creating the session</b>:<br/>
 use <a class="el" href="group__PJNATH__TURN__SESSION.htm#ga54f3cbdf472ffcbb0b5ffb7fda2a7191">pj_turn_session_create()</a> to create the session.</li>
</ul>
<ul>
<li><b>Configuring credential</b>:<br/>
 all TURN operations requires the use of authentication (it uses STUN long term autentication method). Use <a class="el" href="group__PJNATH__TURN__SESSION.htm#ga30e58bdcfa5e3558f359aaee21d9dca5">pj_turn_session_set_credential()</a> to configure the TURN credential to be used by the session.</li>
</ul>
<ul>
<li><b>Configuring server</b>:<br/>
 application must call <a class="el" href="group__PJNATH__TURN__SESSION.htm#ga6bdcca67965ac43d3b7cd79b99a38278">pj_turn_session_set_server()</a> before it can send Allocate request (with <a class="el" href="group__PJNATH__TURN__SESSION.htm#ga168d6661649020978826cea53f211b11">pj_turn_session_alloc()</a>). This function will resolve the TURN server using DNS SRV resolution if the <em>resolver</em> is set. The server resolution process will complete asynchronously, and application will be notified in <em>on_state()</em> callback of the <a class="el" href="structpj__turn__session__cb.htm">pj_turn_session_cb</a> structurewith the session state set to PJ_TURN_STATE_RESOLVED.</li>
</ul>
<ul>
<li><b>Creating allocation</b>:<br/>
 create one "relay port" (or called <b>relayed-transport-address</b> in TURN terminology) in the TURN server by using <a class="el" href="group__PJNATH__TURN__SESSION.htm#ga168d6661649020978826cea53f211b11">pj_turn_session_alloc()</a>. This will send Allocate request to the server. This function will complete immediately, and application will be notified about the allocation result in the <em>on_state()</em> callback of the <a class="el" href="structpj__turn__session__cb.htm">pj_turn_session_cb</a> structure.</li>
</ul>
<ul>
<li><b>Getting the allocation result</b>:<br/>
 if allocation is successful, the session state will progress to <em>PJ_TURN_STATE_READY</em>, otherwise the state will be <em>PJ_TURN_STATE_DEALLOCATED</em> or higher. Session state progression is reported in the <em>on_state()</em> callback of the <a class="el" href="structpj__turn__session__cb.htm">pj_turn_session_cb</a> structure. On successful allocation, application may retrieve the allocation info by calling <a class="el" href="group__PJNATH__TURN__SESSION.htm#ga2ceac5ff7523f578f17cbf93b283d411">pj_turn_session_get_info()</a>.</li>
</ul>
<ul>
<li><b>Sending data through the relay</b>.<br/>
 Once allocation has been created, client may send data to any remote endpoints (called peers in TURN terminology) via the "relay port". It does so by calling <a class="el" href="group__PJNATH__TURN__SESSION.htm#gaefe8e88c0511df20874a1195527d988a">pj_turn_session_sendto()</a>, giving the peer address in the function argument. But note that at this point peers are not allowed to send data towards the client (via the "relay port") before permission is installed for that peer.</li>
</ul>
<ul>
<li><b>Creating permissions</b>.<br/>
 Permission needs to be created in the TURN server so that a peer can send data to the client via the relay port (a peer in this case is identified by its IP address). Without this, when the TURN server receives data from the peer in the "relay port", it will drop this data. Create the permission by calling <a class="el" href="group__PJNATH__TURN__SESSION.htm#ga0d44a18b6923a0dd760947880ca08646">pj_turn_session_set_perm()</a>, specifying the peer IP address in the argument (the port part of the address is ignored). More than one IP addresses may be specified.</li>
</ul>
<ul>
<li><b>Receiving data from peers</b>.<br/>
 Once permission has been installed for the peer, any data received by the TURN server (from that peer) in the "relay port" will be relayed back to client by the server, and application will be notified via <em>on_rx_data</em> callback of the <a class="el" href="structpj__turn__session__cb.htm">pj_turn_session_cb</a>.</li>
</ul>
<ul>
<li><b>Using ChannelData</b>.<br/>
 TURN provides optimized framing to the data by using ChannelData packetization. The client activates this format for the specified peer by calling <a class="el" href="group__PJNATH__TURN__SESSION.htm#ga495c8306ed948c1ac713bfad27151a17">pj_turn_session_bind_channel()</a>. Data sent or received to/for this peer will then use ChannelData format instead of Send or Data Indications.</li>
</ul>
<ul>
<li><b>Refreshing the allocation, permissions, and channel bindings</b>.<br/>
 Allocations, permissions, and channel bindings will be refreshed by the session automatically when they about to expire.</li>
</ul>
<ul>
<li><b>Destroying the allocation</b>.<br/>
 Once the "relay port" is no longer needed, client destroys the allocation by calling <a class="el" href="group__PJNATH__TURN__SESSION.htm#ga3f97ccb740c68be36698800209761043">pj_turn_session_shutdown()</a>. This function will return immediately, and application will be notified about the deallocation result in the <em>on_state()</em> callback of the <a class="el" href="structpj__turn__session__cb.htm">pj_turn_session_cb</a> structure. Once the state has reached PJ_TURN_STATE_DESTROYING, application must assume that the session will be destroyed shortly after. </li>
</ul>
<hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="ga6b1aed7eb13119538d38728b02ef6c83"></a><!-- doxytag: member="turn_session.h::pj_turn_session" ref="ga6b1aed7eb13119538d38728b02ef6c83" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="group__PJNATH__TURN__SESSION.htm#ga6b1aed7eb13119538d38728b02ef6c83">pj_turn_session</a> <a class="el" href="group__PJNATH__TURN__SESSION.htm#ga6b1aed7eb13119538d38728b02ef6c83">pj_turn_session</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Opaque declaration for TURN client session. </p>

</div>
</div>
<hr/><h2>Enumeration Type Documentation</h2>
<a class="anchor" id="ga763f751e1663de5a61b9e9013541530d"></a><!-- doxytag: member="turn_session.h::pj_turn_state_t" ref="ga763f751e1663de5a61b9e9013541530d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__PJNATH__TURN__SESSION.htm#ga763f751e1663de5a61b9e9013541530d">pj_turn_state_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>TURN session state </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="gga763f751e1663de5a61b9e9013541530da26f5e0dba9aaf21f3066102652dabca3"></a><!-- doxytag: member="PJ_TURN_STATE_NULL" ref="gga763f751e1663de5a61b9e9013541530da26f5e0dba9aaf21f3066102652dabca3" args="" -->PJ_TURN_STATE_NULL</em>&nbsp;</td><td>
<p>TURN session has just been created. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga763f751e1663de5a61b9e9013541530da3777036805c19f0a4a482028d31953ae"></a><!-- doxytag: member="PJ_TURN_STATE_RESOLVING" ref="gga763f751e1663de5a61b9e9013541530da3777036805c19f0a4a482028d31953ae" args="" -->PJ_TURN_STATE_RESOLVING</em>&nbsp;</td><td>
<p>TURN server has been configured and now is being resolved via DNS SRV resolution. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga763f751e1663de5a61b9e9013541530dac8685cb2b1415fb0eef0c46eb73224ac"></a><!-- doxytag: member="PJ_TURN_STATE_RESOLVED" ref="gga763f751e1663de5a61b9e9013541530dac8685cb2b1415fb0eef0c46eb73224ac" args="" -->PJ_TURN_STATE_RESOLVED</em>&nbsp;</td><td>
<p>TURN server has been resolved. If there is pending allocation to be done, it will be invoked immediately. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga763f751e1663de5a61b9e9013541530da7d184e0b189d3d3831a109ac6e4cfe3b"></a><!-- doxytag: member="PJ_TURN_STATE_ALLOCATING" ref="gga763f751e1663de5a61b9e9013541530da7d184e0b189d3d3831a109ac6e4cfe3b" args="" -->PJ_TURN_STATE_ALLOCATING</em>&nbsp;</td><td>
<p>TURN session has issued ALLOCATE request and is waiting for response from the TURN server. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga763f751e1663de5a61b9e9013541530da9d5c96a0383c6401ec06596a6df50a04"></a><!-- doxytag: member="PJ_TURN_STATE_READY" ref="gga763f751e1663de5a61b9e9013541530da9d5c96a0383c6401ec06596a6df50a04" args="" -->PJ_TURN_STATE_READY</em>&nbsp;</td><td>
<p>TURN session has successfully allocated relay resoruce and now is ready to be used. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga763f751e1663de5a61b9e9013541530dab4282c3b4422839d6ab1ffc18e751ce3"></a><!-- doxytag: member="PJ_TURN_STATE_DEALLOCATING" ref="gga763f751e1663de5a61b9e9013541530dab4282c3b4422839d6ab1ffc18e751ce3" args="" -->PJ_TURN_STATE_DEALLOCATING</em>&nbsp;</td><td>
<p>TURN session has issued deallocate request and is waiting for a response from the TURN server. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga763f751e1663de5a61b9e9013541530da5a387f364ae3125b72ba8ab205a0cf2c"></a><!-- doxytag: member="PJ_TURN_STATE_DEALLOCATED" ref="gga763f751e1663de5a61b9e9013541530da5a387f364ae3125b72ba8ab205a0cf2c" args="" -->PJ_TURN_STATE_DEALLOCATED</em>&nbsp;</td><td>
<p>Deallocate response has been received. Normally the session will proceed to DESTROYING state immediately. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga763f751e1663de5a61b9e9013541530dab9e29e0ce5f91e5c91acf58054303fbf"></a><!-- doxytag: member="PJ_TURN_STATE_DESTROYING" ref="gga763f751e1663de5a61b9e9013541530dab9e29e0ce5f91e5c91acf58054303fbf" args="" -->PJ_TURN_STATE_DESTROYING</em>&nbsp;</td><td>
<p>TURN session is being destroyed. </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="ga0dfed6bb5edc5fe18950a46da5ff591e"></a><!-- doxytag: member="turn_session.h::pj_turn_tp_type" ref="ga0dfed6bb5edc5fe18950a46da5ff591e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__PJNATH__TURN__SESSION.htm#ga0dfed6bb5edc5fe18950a46da5ff591e">pj_turn_tp_type</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>TURN transport types, which will be used both to specify the connection type for reaching TURN server and the type of allocation transport to be requested to server (the REQUESTED-TRANSPORT attribute). </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="gga0dfed6bb5edc5fe18950a46da5ff591ea863d21c16c6678359201dda47a7712d5"></a><!-- doxytag: member="PJ_TURN_TP_UDP" ref="gga0dfed6bb5edc5fe18950a46da5ff591ea863d21c16c6678359201dda47a7712d5" args="" -->PJ_TURN_TP_UDP</em>&nbsp;</td><td>
<p>UDP transport, which value corresponds to IANA protocol number. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga0dfed6bb5edc5fe18950a46da5ff591ea060378594a0fcb19a419d3e71614f449"></a><!-- doxytag: member="PJ_TURN_TP_TCP" ref="gga0dfed6bb5edc5fe18950a46da5ff591ea060378594a0fcb19a419d3e71614f449" args="" -->PJ_TURN_TP_TCP</em>&nbsp;</td><td>
<p>TCP transport, which value corresponds to IANA protocol number. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga0dfed6bb5edc5fe18950a46da5ff591eae461ce18021d349208f36d9553e93226"></a><!-- doxytag: member="PJ_TURN_TP_TLS" ref="gga0dfed6bb5edc5fe18950a46da5ff591eae461ce18021d349208f36d9553e93226" args="" -->PJ_TURN_TP_TLS</em>&nbsp;</td><td>
<p>TLS transport. The TLS transport will only be used as the connection type to reach the server and never as the allocation transport type. </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ga7807ca242062938a51d3a626a936a675"></a><!-- doxytag: member="turn_session.h::pj_turn_alloc_param_copy" ref="ga7807ca242062938a51d3a626a936a675" args="(pj_pool_t *pool, pj_turn_alloc_param *dst, const pj_turn_alloc_param *src)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__PJNATH__TURN__SESSION.htm#ga7807ca242062938a51d3a626a936a675">pj_turn_alloc_param_copy</a> </td>
          <td>(</td>
          <td class="paramtype">pj_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpj__turn__alloc__param.htm">pj_turn_alloc_param</a> *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpj__turn__alloc__param.htm">pj_turn_alloc_param</a> *&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Duplicate <a class="el" href="structpj__turn__alloc__param.htm">pj_turn_alloc_param</a>.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pool</td><td>Pool to allocate memory (currently not used) </td></tr>
    <tr><td class="paramname">dst</td><td>Destination parameter. </td></tr>
    <tr><td class="paramname">src</td><td>Source parameter. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gacf9769bbe27bd7c5138cf7dce13c5d26"></a><!-- doxytag: member="turn_session.h::pj_turn_alloc_param_default" ref="gacf9769bbe27bd7c5138cf7dce13c5d26" args="(pj_turn_alloc_param *prm)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__PJNATH__TURN__SESSION.htm#gacf9769bbe27bd7c5138cf7dce13c5d26">pj_turn_alloc_param_default</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpj__turn__alloc__param.htm">pj_turn_alloc_param</a> *&#160;</td>
          <td class="paramname"><em>prm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Initialize <a class="el" href="structpj__turn__alloc__param.htm">pj_turn_alloc_param</a> with the default values.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">prm</td><td>The TURN allocation parameter to be initialized. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga168d6661649020978826cea53f211b11"></a><!-- doxytag: member="turn_session.h::pj_turn_session_alloc" ref="ga168d6661649020978826cea53f211b11" args="(pj_turn_session *sess, const pj_turn_alloc_param *param)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pj_status_t <a class="el" href="group__PJNATH__TURN__SESSION.htm#ga168d6661649020978826cea53f211b11">pj_turn_session_alloc</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__PJNATH__TURN__SESSION.htm#ga6b1aed7eb13119538d38728b02ef6c83">pj_turn_session</a> *&#160;</td>
          <td class="paramname"><em>sess</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpj__turn__alloc__param.htm">pj_turn_alloc_param</a> *&#160;</td>
          <td class="paramname"><em>param</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Allocate a relay address/resource in the TURN server by sending TURN Allocate request. Application must first initiate the server resolution process with <a class="el" href="group__PJNATH__TURN__SESSION.htm#ga6bdcca67965ac43d3b7cd79b99a38278">pj_turn_session_set_server()</a> and set the credential to be used with <a class="el" href="group__PJNATH__TURN__SESSION.htm#ga30e58bdcfa5e3558f359aaee21d9dca5">pj_turn_session_set_credential()</a> before calling this function.</p>
<p>This function will complete asynchronously, and the application will be notified about the allocation result in <em>on_state()</em> callback. The TURN session state will move to PJ_TURN_STATE_READY if allocation is successful, and PJ_TURN_STATE_DEALLOCATING or greater state if allocation has failed.</p>
<p>Once allocation has been successful, the TURN session will keep this allocation alive until the session is destroyed, by sending periodic allocation refresh to the TURN server.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">sess</td><td>The TURN client session. </td></tr>
    <tr><td class="paramname">param</td><td>Optional TURN allocation parameter.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>PJ_SUCCESS if the operation has been successfully initiated or the appropriate error code on failure. </dd></dl>

</div>
</div>
<a class="anchor" id="ga495c8306ed948c1ac713bfad27151a17"></a><!-- doxytag: member="turn_session.h::pj_turn_session_bind_channel" ref="ga495c8306ed948c1ac713bfad27151a17" args="(pj_turn_session *sess, const pj_sockaddr_t *peer, unsigned addr_len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pj_status_t <a class="el" href="group__PJNATH__TURN__SESSION.htm#ga495c8306ed948c1ac713bfad27151a17">pj_turn_session_bind_channel</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__PJNATH__TURN__SESSION.htm#ga6b1aed7eb13119538d38728b02ef6c83">pj_turn_session</a> *&#160;</td>
          <td class="paramname"><em>sess</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const pj_sockaddr_t *&#160;</td>
          <td class="paramname"><em>peer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>addr_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Optionally establish channel binding for the specified a peer address. This function will assign a unique channel number for the peer address and request channel binding to the TURN server for this address. When a channel has been bound to a peer, the TURN client and TURN server will exchange data using ChannelData encapsulation format, which has lower bandwidth overhead than Send Indication (the default format used when peer address is not bound to a channel).</p>
<p>This function will complete asynchronously, and application will be notified about the result in <em>on_channel_bound()</em> callback.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">sess</td><td>The TURN client session. </td></tr>
    <tr><td class="paramname">peer</td><td>The remote peer address. </td></tr>
    <tr><td class="paramname">addr_len</td><td>Length of the address.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>PJ_SUCCESS if the operation has been successfully initiated, or the appropriate error code on failure. </dd></dl>

</div>
</div>
<a class="anchor" id="ga54f3cbdf472ffcbb0b5ffb7fda2a7191"></a><!-- doxytag: member="turn_session.h::pj_turn_session_create" ref="ga54f3cbdf472ffcbb0b5ffb7fda2a7191" args="(const pj_stun_config *cfg, const char *name, int af, pj_turn_tp_type conn_type, pj_grp_lock_t *grp_lock, const pj_turn_session_cb *cb, unsigned options, void *user_data, pj_turn_session **p_sess)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pj_status_t <a class="el" href="group__PJNATH__TURN__SESSION.htm#ga54f3cbdf472ffcbb0b5ffb7fda2a7191">pj_turn_session_create</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structpj__stun__config.htm">pj_stun_config</a> *&#160;</td>
          <td class="paramname"><em>cfg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>af</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PJNATH__TURN__SESSION.htm#ga0dfed6bb5edc5fe18950a46da5ff591e">pj_turn_tp_type</a>&#160;</td>
          <td class="paramname"><em>conn_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pj_grp_lock_t *&#160;</td>
          <td class="paramname"><em>grp_lock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpj__turn__session__cb.htm">pj_turn_session_cb</a> *&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PJNATH__TURN__SESSION.htm#ga6b1aed7eb13119538d38728b02ef6c83">pj_turn_session</a> **&#160;</td>
          <td class="paramname"><em>p_sess</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a TURN session instance with the specified address family and connection type. Once TURN session instance is created, application must call <a class="el" href="group__PJNATH__TURN__SESSION.htm#ga168d6661649020978826cea53f211b11">pj_turn_session_alloc()</a> to allocate a relay address in the TURN server.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">cfg</td><td>The STUN configuration which contains among other things the ioqueue and timer heap instance for the operation of this session. </td></tr>
    <tr><td class="paramname">name</td><td>Optional name to identify this session in the log. </td></tr>
    <tr><td class="paramname">af</td><td>Address family of the client connection. Currently pj_AF_INET() and pj_AF_INET6() are supported. </td></tr>
    <tr><td class="paramname">conn_type</td><td>Connection type to the TURN server. </td></tr>
    <tr><td class="paramname">grp_lock</td><td>Optional group lock object to be used by this session. If this value is NULL, the session will create a group lock internally. </td></tr>
    <tr><td class="paramname">cb</td><td>Callback to receive events from the TURN session. </td></tr>
    <tr><td class="paramname">options</td><td>Option flags, currently this value must be zero. </td></tr>
    <tr><td class="paramname">user_data</td><td>Arbitrary application data to be associated with this transport. </td></tr>
    <tr><td class="paramname">p_sess</td><td>Pointer to receive the created instance of the TURN session.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>PJ_SUCCESS if the operation has been successful, or the appropriate error code on failure. </dd></dl>

</div>
</div>
<a class="anchor" id="ga6128f788c801e8cebdc259da48506b4f"></a><!-- doxytag: member="turn_session.h::pj_turn_session_destroy" ref="ga6128f788c801e8cebdc259da48506b4f" args="(pj_turn_session *sess, pj_status_t last_err)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pj_status_t <a class="el" href="group__PJNATH__TURN__SESSION.htm#ga6128f788c801e8cebdc259da48506b4f">pj_turn_session_destroy</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__PJNATH__TURN__SESSION.htm#ga6b1aed7eb13119538d38728b02ef6c83">pj_turn_session</a> *&#160;</td>
          <td class="paramname"><em>sess</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pj_status_t&#160;</td>
          <td class="paramname"><em>last_err</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Forcefully destroy the TURN session. This will destroy the session immediately. If there is an active allocation, the server will not be notified about the client destruction.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">sess</td><td>The TURN client session. </td></tr>
    <tr><td class="paramname">last_err</td><td>Optional error code to be set to the session, which would be returned back in the <em>info</em> parameter of <a class="el" href="group__PJNATH__TURN__SESSION.htm#ga2ceac5ff7523f578f17cbf93b283d411">pj_turn_session_get_info()</a>. If this argument value is PJ_SUCCESS, the error code will not be set. If the session already has an error code set, this function will not overwrite that error code either.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>PJ_SUCCESS if the operation has been successful, or the appropriate error code on failure. </dd></dl>

</div>
</div>
<a class="anchor" id="gad0ebf44a71855b18c9bdf8cb2ff25685"></a><!-- doxytag: member="turn_session.h::pj_turn_session_get_grp_lock" ref="gad0ebf44a71855b18c9bdf8cb2ff25685" args="(pj_turn_session *sess)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pj_grp_lock_t* <a class="el" href="group__PJNATH__TURN__SESSION.htm#gad0ebf44a71855b18c9bdf8cb2ff25685">pj_turn_session_get_grp_lock</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__PJNATH__TURN__SESSION.htm#ga6b1aed7eb13119538d38728b02ef6c83">pj_turn_session</a> *&#160;</td>
          <td class="paramname"><em>sess</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get the group lock for this TURN session.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">sess</td><td>The TURN client session.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The group lock. </dd></dl>

</div>
</div>
<a class="anchor" id="ga2ceac5ff7523f578f17cbf93b283d411"></a><!-- doxytag: member="turn_session.h::pj_turn_session_get_info" ref="ga2ceac5ff7523f578f17cbf93b283d411" args="(pj_turn_session *sess, pj_turn_session_info *info)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pj_status_t <a class="el" href="group__PJNATH__TURN__SESSION.htm#ga2ceac5ff7523f578f17cbf93b283d411">pj_turn_session_get_info</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__PJNATH__TURN__SESSION.htm#ga6b1aed7eb13119538d38728b02ef6c83">pj_turn_session</a> *&#160;</td>
          <td class="paramname"><em>sess</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpj__turn__session__info.htm">pj_turn_session_info</a> *&#160;</td>
          <td class="paramname"><em>info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get the information about this TURN session and the allocation, if any.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">sess</td><td>The TURN client session. </td></tr>
    <tr><td class="paramname">info</td><td>The structure to be initialized with the TURN session info.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>PJ_SUCCESS if the operation has been successful, or the appropriate error code on failure. </dd></dl>

</div>
</div>
<a class="anchor" id="ga509471fc6f2030508c6738ac14ace715"></a><!-- doxytag: member="turn_session.h::pj_turn_session_get_user_data" ref="ga509471fc6f2030508c6738ac14ace715" args="(pj_turn_session *sess)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* <a class="el" href="group__PJNATH__TURN__SESSION.htm#ga509471fc6f2030508c6738ac14ace715">pj_turn_session_get_user_data</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__PJNATH__TURN__SESSION.htm#ga6b1aed7eb13119538d38728b02ef6c83">pj_turn_session</a> *&#160;</td>
          <td class="paramname"><em>sess</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Retrieve the previously assigned user data associated with this TURN session.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">sess</td><td>The TURN client session.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The user/application data. </dd></dl>

</div>
</div>
<a class="anchor" id="ga18dd1819995d6a98fdf67f1a56b5ac5f"></a><!-- doxytag: member="turn_session.h::pj_turn_session_on_rx_pkt" ref="ga18dd1819995d6a98fdf67f1a56b5ac5f" args="(pj_turn_session *sess, void *pkt, pj_size_t pkt_len, pj_size_t *parsed_len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pj_status_t <a class="el" href="group__PJNATH__TURN__SESSION.htm#ga18dd1819995d6a98fdf67f1a56b5ac5f">pj_turn_session_on_rx_pkt</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__PJNATH__TURN__SESSION.htm#ga6b1aed7eb13119538d38728b02ef6c83">pj_turn_session</a> *&#160;</td>
          <td class="paramname"><em>sess</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pkt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pj_size_t&#160;</td>
          <td class="paramname"><em>pkt_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pj_size_t *&#160;</td>
          <td class="paramname"><em>parsed_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Notify TURN client session upon receiving a packet from server. Since the TURN session is transport independent, it does not read packet from any sockets, and rather relies on application giving it packets that are received from the TURN server. The session then processes this packet and decides whether it is part of TURN protocol exchange or if it is a data to be reported back to user, which in this case it will call the <em>on_rx_data()</em> callback.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">sess</td><td>The TURN client session. </td></tr>
    <tr><td class="paramname">pkt</td><td>The packet as received from the TURN server. This should contain either STUN encapsulated message or a ChannelData packet. </td></tr>
    <tr><td class="paramname">pkt_len</td><td>The length of the packet. </td></tr>
    <tr><td class="paramname">parsed_len</td><td>Optional argument to receive the number of parsed or processed data from the packet.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The function may return non-PJ_SUCCESS if it receives non-STUN and non-ChannelData packet, or if the <em>on_rx_data()</em> returns non-PJ_SUCCESS; </dd></dl>

</div>
</div>
<a class="anchor" id="gaefe8e88c0511df20874a1195527d988a"></a><!-- doxytag: member="turn_session.h::pj_turn_session_sendto" ref="gaefe8e88c0511df20874a1195527d988a" args="(pj_turn_session *sess, const pj_uint8_t *pkt, unsigned pkt_len, const pj_sockaddr_t *peer_addr, unsigned addr_len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pj_status_t <a class="el" href="group__PJNATH__TURN__SESSION.htm#gaefe8e88c0511df20874a1195527d988a">pj_turn_session_sendto</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__PJNATH__TURN__SESSION.htm#ga6b1aed7eb13119538d38728b02ef6c83">pj_turn_session</a> *&#160;</td>
          <td class="paramname"><em>sess</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const pj_uint8_t *&#160;</td>
          <td class="paramname"><em>pkt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>pkt_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const pj_sockaddr_t *&#160;</td>
          <td class="paramname"><em>peer_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>addr_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Send a data to the specified peer address via the TURN relay. This function will encapsulate the data as STUN Send Indication or TURN ChannelData packet and send the message to the TURN server. The TURN server then will send the data to the peer.</p>
<p>The allocation (<a class="el" href="group__PJNATH__TURN__SESSION.htm#ga168d6661649020978826cea53f211b11">pj_turn_session_alloc()</a>) must have been successfully created before application can relay any data.</p>
<p>Since TURN session is transport independent, this function will ultimately call <em>on_send_pkt()</em> callback to request the application to actually send the packet containing the data to the TURN server.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">sess</td><td>The TURN client session. </td></tr>
    <tr><td class="paramname">pkt</td><td>The data/packet to be sent to peer. </td></tr>
    <tr><td class="paramname">pkt_len</td><td>Length of the data. </td></tr>
    <tr><td class="paramname">peer_addr</td><td>The remote peer address (the ultimate destination of the data, and not the TURN server address). </td></tr>
    <tr><td class="paramname">addr_len</td><td>Length of the address.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>PJ_SUCCESS if the operation has been successful, or the appropriate error code on failure. </dd></dl>

</div>
</div>
<a class="anchor" id="ga30e58bdcfa5e3558f359aaee21d9dca5"></a><!-- doxytag: member="turn_session.h::pj_turn_session_set_credential" ref="ga30e58bdcfa5e3558f359aaee21d9dca5" args="(pj_turn_session *sess, const pj_stun_auth_cred *cred)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pj_status_t <a class="el" href="group__PJNATH__TURN__SESSION.htm#ga30e58bdcfa5e3558f359aaee21d9dca5">pj_turn_session_set_credential</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__PJNATH__TURN__SESSION.htm#ga6b1aed7eb13119538d38728b02ef6c83">pj_turn_session</a> *&#160;</td>
          <td class="paramname"><em>sess</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpj__stun__auth__cred.htm">pj_stun_auth_cred</a> *&#160;</td>
          <td class="paramname"><em>cred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set credential to be used to authenticate against TURN server. Application must call this function before sending Allocate request with <a class="el" href="group__PJNATH__TURN__SESSION.htm#ga168d6661649020978826cea53f211b11">pj_turn_session_alloc()</a>.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">sess</td><td>The TURN client session </td></tr>
    <tr><td class="paramname">cred</td><td>STUN credential to be used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>PJ_SUCCESS if the operation has been successful, or the appropriate error code on failure. </dd></dl>

</div>
</div>
<a class="anchor" id="ga55ec6f5761918be38ade94b2ae3fdcf1"></a><!-- doxytag: member="turn_session.h::pj_turn_session_set_log" ref="ga55ec6f5761918be38ade94b2ae3fdcf1" args="(pj_turn_session *sess, unsigned flags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__PJNATH__TURN__SESSION.htm#ga55ec6f5761918be38ade94b2ae3fdcf1">pj_turn_session_set_log</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__PJNATH__TURN__SESSION.htm#ga6b1aed7eb13119538d38728b02ef6c83">pj_turn_session</a> *&#160;</td>
          <td class="paramname"><em>sess</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Configure message logging. By default all flags are enabled.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">sess</td><td>The TURN client session. </td></tr>
    <tr><td class="paramname">flags</td><td>Bitmask combination of <a class="el" href="group__PJNATH__STUN__SESSION.htm#ga65952e3ea20202965284021d5086e48d">pj_stun_sess_msg_log_flag</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga0d44a18b6923a0dd760947880ca08646"></a><!-- doxytag: member="turn_session.h::pj_turn_session_set_perm" ref="ga0d44a18b6923a0dd760947880ca08646" args="(pj_turn_session *sess, unsigned addr_cnt, const pj_sockaddr addr[], unsigned options)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pj_status_t <a class="el" href="group__PJNATH__TURN__SESSION.htm#ga0d44a18b6923a0dd760947880ca08646">pj_turn_session_set_perm</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__PJNATH__TURN__SESSION.htm#ga6b1aed7eb13119538d38728b02ef6c83">pj_turn_session</a> *&#160;</td>
          <td class="paramname"><em>sess</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>addr_cnt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const pj_sockaddr&#160;</td>
          <td class="paramname"><em>addr</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create or renew permission in the TURN server for the specified peer IP addresses. Application must install permission for a particular (peer) IP address before it sends any data to that IP address, or otherwise the TURN server will drop the data.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">sess</td><td>The TURN client session. </td></tr>
    <tr><td class="paramname">addr_cnt</td><td>Number of IP addresses. </td></tr>
    <tr><td class="paramname">addr</td><td>Array of peer IP addresses. Only the address family and IP address portion of the socket address matter. </td></tr>
    <tr><td class="paramname">options</td><td>Specify 1 to let the TURN client session automatically renew the permission later when they are about to expire.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>PJ_SUCCESS if the operation has been successfully issued, or the appropriate error code. Note that the operation itself will complete asynchronously. </dd></dl>

</div>
</div>
<a class="anchor" id="ga6bdcca67965ac43d3b7cd79b99a38278"></a><!-- doxytag: member="turn_session.h::pj_turn_session_set_server" ref="ga6bdcca67965ac43d3b7cd79b99a38278" args="(pj_turn_session *sess, const pj_str_t *domain, int default_port, pj_dns_resolver *resolver)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pj_status_t <a class="el" href="group__PJNATH__TURN__SESSION.htm#ga6bdcca67965ac43d3b7cd79b99a38278">pj_turn_session_set_server</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__PJNATH__TURN__SESSION.htm#ga6b1aed7eb13119538d38728b02ef6c83">pj_turn_session</a> *&#160;</td>
          <td class="paramname"><em>sess</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const pj_str_t *&#160;</td>
          <td class="paramname"><em>domain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>default_port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pj_dns_resolver *&#160;</td>
          <td class="paramname"><em>resolver</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set the server or domain name of the server. Before the application can send Allocate request (with <a class="el" href="group__PJNATH__TURN__SESSION.htm#ga168d6661649020978826cea53f211b11">pj_turn_session_alloc()</a>), it must first resolve the server address(es) using this function. This function will resolve the TURN server using DNS SRV resolution if the <em>resolver</em> is set. The server resolution process will complete asynchronously, and application will be notified in <em>on_state()</em> callback with the session state set to PJ_TURN_STATE_RESOLVED.</p>
<p>Application may call with <a class="el" href="group__PJNATH__TURN__SESSION.htm#ga168d6661649020978826cea53f211b11">pj_turn_session_alloc()</a> before the server resolution completes. In this case, the operation will be queued by the session, and it will be sent once the server resolution completes.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">sess</td><td>The TURN client session. </td></tr>
    <tr><td class="paramname">domain</td><td>The domain, hostname, or IP address of the TURN server. When this parameter contains domain name, the <em>resolver</em> parameter must be set to activate DNS SRV resolution. </td></tr>
    <tr><td class="paramname">default_port</td><td>The default TURN port number to use when DNS SRV resolution is not used. If DNS SRV resolution is used, the server port number will be set from the DNS SRV records. </td></tr>
    <tr><td class="paramname">resolver</td><td>If this parameter is not NULL, then the <em>domain</em> parameter will be first resolved with DNS SRV and then fallback to using DNS A/AAAA resolution when DNS SRV resolution fails. If this parameter is NULL, the <em>domain</em> parameter will be resolved as hostname.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>PJ_SUCCESS if the operation has been successfully queued, or the appropriate error code on failure. When this function returns PJ_SUCCESS, the final result of the resolution process will be notified to application in <em>on_state()</em> callback. </dd></dl>

</div>
</div>
<a class="anchor" id="ga0737f8c0be3719df43794ce16aa84356"></a><!-- doxytag: member="turn_session.h::pj_turn_session_set_software_name" ref="ga0737f8c0be3719df43794ce16aa84356" args="(pj_turn_session *sess, const pj_str_t *sw)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pj_status_t <a class="el" href="group__PJNATH__TURN__SESSION.htm#ga0737f8c0be3719df43794ce16aa84356">pj_turn_session_set_software_name</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__PJNATH__TURN__SESSION.htm#ga6b1aed7eb13119538d38728b02ef6c83">pj_turn_session</a> *&#160;</td>
          <td class="paramname"><em>sess</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const pj_str_t *&#160;</td>
          <td class="paramname"><em>sw</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Configure the SOFTWARE name to be sent in all STUN requests by the TURN session.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">sess</td><td>The TURN client session. </td></tr>
    <tr><td class="paramname">sw</td><td>Software name string. If this argument is NULL or empty, the session will not include SOFTWARE attribute in STUN requests and responses.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>PJ_SUCCESS on success, or the appropriate error code. </dd></dl>

</div>
</div>
<a class="anchor" id="ga5e2ebb2697547d4805a0c661dce11fa1"></a><!-- doxytag: member="turn_session.h::pj_turn_session_set_user_data" ref="ga5e2ebb2697547d4805a0c661dce11fa1" args="(pj_turn_session *sess, void *user_data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pj_status_t <a class="el" href="group__PJNATH__TURN__SESSION.htm#ga5e2ebb2697547d4805a0c661dce11fa1">pj_turn_session_set_user_data</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__PJNATH__TURN__SESSION.htm#ga6b1aed7eb13119538d38728b02ef6c83">pj_turn_session</a> *&#160;</td>
          <td class="paramname"><em>sess</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Associate a user data with this TURN session. The user data may then be retrieved later with <a class="el" href="group__PJNATH__TURN__SESSION.htm#ga509471fc6f2030508c6738ac14ace715">pj_turn_session_get_user_data()</a>.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">sess</td><td>The TURN client session. </td></tr>
    <tr><td class="paramname">user_data</td><td>Arbitrary data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>PJ_SUCCESS if the operation has been successful, or the appropriate error code on failure. </dd></dl>

</div>
</div>
<a class="anchor" id="ga3f97ccb740c68be36698800209761043"></a><!-- doxytag: member="turn_session.h::pj_turn_session_shutdown" ref="ga3f97ccb740c68be36698800209761043" args="(pj_turn_session *sess)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pj_status_t <a class="el" href="group__PJNATH__TURN__SESSION.htm#ga3f97ccb740c68be36698800209761043">pj_turn_session_shutdown</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__PJNATH__TURN__SESSION.htm#ga6b1aed7eb13119538d38728b02ef6c83">pj_turn_session</a> *&#160;</td>
          <td class="paramname"><em>sess</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Shutdown TURN client session. This will gracefully deallocate and destroy the client session.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">sess</td><td>The TURN client session.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>PJ_SUCCESS if the operation has been successful, or the appropriate error code on failure. </dd></dl>

</div>
</div>
<a class="anchor" id="ga9f1e11aa8d185d8c383b64fcbd24ce95"></a><!-- doxytag: member="turn_session.h::pj_turn_state_name" ref="ga9f1e11aa8d185d8c383b64fcbd24ce95" args="(pj_turn_state_t state)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* <a class="el" href="group__PJNATH__TURN__SESSION.htm#ga9f1e11aa8d185d8c383b64fcbd24ce95">pj_turn_state_name</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__PJNATH__TURN__SESSION.htm#ga763f751e1663de5a61b9e9013541530d">pj_turn_state_t</a>&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get string representation for the given TURN state.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>The TURN session state.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The state name as NULL terminated string. </dd></dl>

</div>
</div>
</div><!-- contents -->
	</TD></TD></TABLE>
<p>&nbsp;</p>
<hr><center>
PJNATH - Open Source NAT traversal helper library supporting STUN, TURN, and ICE<br>
Copyright (C) 2006-2009 Teluu Inc.
</center>


<!--#include virtual="/footer.html" -->

</BODY>
</HTML>
